{"mappings":"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","sources":["src/complexgrapher/worker/chunkloader.ts","src/complexgrapher/types.ts","node_modules/.pnpm/@swc+helpers@0.4.3/node_modules/@swc/helpers/src/_to_array.mjs","src/complexgrapher/evaluator.ts"],"sourcesContent":["import { Complex, CanvasData, ChunkData, PartialEvaluator, Evaluator, LoaderIn, LoaderOut, MainIn, InitIn, ComplexFunction, MainOut } from \"../types\";\nimport * as evaluator from \"../evaluator\";\n\nconst resolution = 1;\n\nonmessage = function (e: MessageEvent<InitIn | MainIn | LoaderIn>) {\n    let data = e.data;\n\n    if (data.action === \"init\") {\n        self.postMessage({action: \"ready\"});\n        return;\n    }\n\n    let { pev, cd, graphID } = data;\n    let ev = buildEvaluator(pev);\n\n    if (data.action === \"chunkRequest\") {\n        let chunk = data.chunk;\n\n        let buf = computeBuffer(ev, cd, chunk);\n        let msg: LoaderOut = { action: \"chunkDone\", buf, chunk, graphID };\n        postMessage(msg, [buf] as any);\n    } else if (data.action === \"mainRequest\") {\n        const start = performance.now();\n\n        // TODO, use like actual methods here.\n        for (let i = 0; i < cd.width; i += 100) {\n            for (let j = 0; j < cd.height; j += 100) {\n                let chunk = { width: 100, height: 100, offx: i, offy: j };\n                let buf = computeBuffer(ev, cd, chunk);\n\n                let msg: LoaderOut = { action: \"chunkDone\", buf, chunk, graphID };\n                postMessage(msg, [buf] as any);\n                console.log(msg);\n            }\n        }\n\n        let msg: MainOut = {action: \"done\", time: Math.trunc(performance.now() - start), graphID};\n        postMessage(msg);\n    } else {\n        let _: never = data;\n        throw new Error(\"Unrecognized request into chunkLoader\");\n    }\n}\n\n/**\n * Take a partially computed evaluator and fully evaluate it.\n * @param pev partially computed evaluator\n * @returns the full evaluator\n */\nfunction buildEvaluator(pev: PartialEvaluator): Evaluator {\n    let {fstr, inverse} = pev;\n    return {evaluator: evaluator.compile(fstr), inverse}\n}\n\n/**\n * Compute the ArrayBuffer for the chunk\n * @param ev The function evaluator\n * @param cd Canvas dimension data\n * @param chunk Chunk position and size\n * @returns the computed chunk\n */\nfunction computeBuffer(ev: Evaluator, cd: CanvasData, chunk: ChunkData): ArrayBuffer {\n    let {evaluator, inverse} = ev;\n    let {width, height} = chunk;\n\n    let buf = new ArrayBuffer(4 * width * height);\n    let arr32 = new Uint32Array(buf);\n\n    if (evaluator.type === \"constant\") {\n        const fz = Complex(evaluator.f);\n        arr32.fill( polarToColor(fz.abs(), fz.arg(), inverse) );\n    } else {\n        const { f } = evaluator;\n        \n        for (var j = 0; j < height; j += resolution) {\n            const row = Uint32Array.from({length: width}, (_, i) => {\n                // compute value\n                let fz: Complex = Complex(f( convPlanes(Math.floor(i / resolution) * resolution, j, cd, chunk) ));\n    \n                let r = fz.abs();\n                let phi = fz.arg();\n\n                return polarToColor(r, phi, inverse);\n            });\n            \n            for (let k = 0; k < resolution && (j + k) < height; k++) {\n                const offset = (j + k) * width;\n                arr32.set(row, offset);\n            }\n        }\n    }\n\n    return buf;\n}\n\n/**\n  * Converts xy canvas pixels to values in the complex plane\n * @param x x coord\n * @param y y coord\n * @param cd canvas data\n * @param chunk chunk offset data\n * @returns the complex value associated\n */\nfunction convPlanes(x: number, y: number, cd: CanvasData, chunk: ChunkData) {\n    const { width, height, scale, center: [cx, cy] } = cd;\n    const { offx, offy } = chunk;\n    const scaleX = scale * width / height;\n    const scaleY = scale;\n\n    // distance of each radius\n    let [rx, ry] = [\n        (width  - 1) / 2,\n        (height - 1) / 2\n    ];\n\n    // normalized distance from center (This means the center is at 0, the edges are at Â±1).\n    // the center is also (rx, ry)\n    let [nx, ny] = [\n         (x + offx - rx) / rx, \n        -(y + offy - ry) / ry\n    ];\n    \n    return Complex(cx + nx * scaleX, cy + ny * scaleY);\n}\n\n/**\n * Takes a polar coordinate and maps it to a color\n * @param rad Radius\n * @param theta Angle\n * @param inverse Whether to invert the brightness\n * @returns the associated color in RGB\n */\nfunction polarToColor(rad: number, theta: number, inverse: boolean) {\n    let hue = mod(theta * 3 / Math.PI, 6); // hue [0,6)\n    if (inverse) hue = 6 - hue;\n\n    return hsl2rgb(\n        hue,\n        1,\n        bfunc(rad, inverse),\n    );\n}\n\n/**\n * Converts HSL to RGBA\n * @param h hue [0, 6]\n * @param s saturation [0, 1]\n * @param l lightness [0, 1]\n * @returns 4-byte RGBA number ([0, 255], alpha is always 255)\n */\nfunction hsl2rgb(h: number, s: number, l: number) {\n    let c, x, m, r, g, b;\n    c = (1 - Math.abs(2 * l - 1)) * s;\n    x = c * (1 - Math.abs(mod(h, 2) - 1));\n    m = l - c / 2;\n    if (0 <= h && h < 1) [r, g, b] = [c, x, 0];\n    else if (1 <= h && h < 2) [r, g, b] = [x, c, 0];\n    else if (2 <= h && h < 3) [r, g, b] = [0, c, x];\n    else if (3 <= h && h < 4) [r, g, b] = [0, x, c];\n    else if (4 <= h && h < 5) [r, g, b] = [x, 0, c];\n    else if (5 <= h && h < 6) [r, g, b] = [c, 0, x];\n    else [r, g, b] = [c, x, 0];\n\n    return (    0xFF  << 24) | \n    (((b + m) * 0xFF) << 16) |\n    (((g + m) * 0xFF) <<  8) |\n     ((r + m) * 0xFF);\n}\n\n/**\n * Brightness computation\n * @param r Radius\n * @param inv Whether to invert the brightness\n * @returns the brightness as float\n */\nfunction bfunc(r: number, inv: boolean) {\n    // bfunc needs to match the identities:\n    // b(1/x) = 1 - b(x)\n    // b(0) = 0\n\n    // the current impl uses b(x) = 1 - 1/(x^n + 1)\n    // another possible impl: b(x) = 2 * atan(x) / pi\n\n    let b = 1 / (Math.sqrt(r) + 1);\n\n    return inv ? 1 - b : b;\n}\n\nfunction mod(x: number, y: number) {\n    return ((x % y) + y) % y;\n}","import { Complex } from \"complex.js\";\nexport { Complex };\n\n/**\n * Canvas dimension data (width and height), as well as the current zoom level\n */\nexport interface CanvasData {\n    width: number,\n    height: number,\n\n    center: [number, number],\n    scale: number,\n}\n\n/**\n * Chunk data designating the size of the chunk and its offset from (0, 0) in canvas\n */\nexport interface ChunkData {\n    width: number,\n    height: number,\n    offx: number,\n    offy: number\n}\n\n/**\n * A partially evaluated function string.\n * The string here is already simplified, and the reciprocal optimization has already been applied,\n * but the is not fully computed to allow it to be passed as a Worker message.\n */\nexport interface PartialEvaluator {\n    fstr: string,\n    inverse: boolean\n}\n\ntype Numeric = Complex | number;\n\ninterface FunctionEvaluator { \n    type: \"function\",\n    f: ComplexFunction\n}\ninterface ConstantEvaluator { \n    type: \"constant\",\n    f: Numeric\n}\n\n/**\n * A fully evaluated function.\n * This has the sufficient knowledge to compute an output color from an input complex number.\n */\nexport interface Evaluator {\n    evaluator: FunctionEvaluator | ConstantEvaluator,\n\n    /**\n     * Signifies whether to use the reciprocal optimization: bfunc(1 / fz) = 1 - bfunc(fz)\n     */\n    inverse: boolean\n}\n\n/**\n * A function that takes a complex number to another complex number\n */\nexport type ComplexFunction = (z: Complex) => Numeric;\n\nnamespace Messages {\n    /**\n     * A request to compute the function across an entire canvas\n     */\n    export interface MainRequest {\n        action: \"mainRequest\",\n        pev: PartialEvaluator,\n        cd: CanvasData,\n        graphID: number\n    };\n    \n    /**\n     * Designation that the canvas is fully computed\n     */\n    export interface GraphDone {\n        action: \"done\",\n        time: number,\n        graphID: number\n    };\n\n    /**\n     * A request to compute the function across a chunk\n     */\n    export interface ChunkRequest {\n        action: \"chunkRequest\",\n        pev: PartialEvaluator,\n        cd: CanvasData,\n        chunk: ChunkData,\n        graphID: number\n    };\n\n    /**\n     * Designation that the chunk is fully computed (with the computed data from the chunk)\n     */\n    export interface ChunkDone {\n        action: \"chunkDone\",\n        chunk: ChunkData,\n        buf: ArrayBuffer,\n        graphID: number\n    };\n\n    /**\n     * Call to initialize\n     */\n    export interface Init {\n        action: \"init\"\n    };\n\n    /**\n     * Return call to designate initialization completed\n     */\n    export interface Ready {\n        action: \"ready\"\n    }\n\n}\nexport type InitIn = Messages.Init;\nexport type InitOut = Messages.Ready;\n\nexport type MainIn = Messages.MainRequest;\nexport type MainOut = Messages.ChunkDone | Messages.GraphDone;\n\nexport type LoaderIn = Messages.ChunkRequest;\nexport type LoaderOut = Messages.ChunkDone;","import arrayWithHoles from './_array_with_holes.mjs';\nimport iterableToArray from './_iterable_to_array.mjs';\nimport nonIterableRest from './_non_iterable_rest.mjs';\nimport unsupportedIterableToArray from './_unsupported_iterable_to_array.mjs';\n\nexport default function _toArray(arr) {\n  return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n","import { all, create } from \"mathjs\";\nimport { Complex, ComplexFunction, Evaluator } from \"./types\";\nconst math = create(all);\n\ntype Numeric = Complex | number;\ntype ComplexMethod<R = Numeric> = (this: Complex, ...args: any[]) => R;\n\n/**\n * A mapping of names to constants which they represent:\n */\nconst constants = {\n    pi: Complex.PI,\n    e: Complex.E,\n    i: Complex.I,\n    inf: Complex.INFINITY,\n    infinity: Complex.INFINITY,\n    epsilon: Complex.EPSILON,\n    nan: Complex.NAN\n} as const;\n\n/**\n * A mapping of names to functions (C -> C) which they represent.\n */\nconst functions: { readonly [s: string]: ComplexMethod<any> } = {\n    gamma() { return math.gamma(this as any); }, // slower than pure Complex.js, but oh well\n    ln: Complex.prototype.log,\n} as const;\n\n/**\n * A mapping of operators to their respective functions.\n */\nconst operators: { [s: string]: ComplexMethod } = {\n    add:        Complex.prototype.add,\n    unaryPlus() { return this; },\n    subtract:   Complex.prototype.sub,\n    unaryMinus: Complex.prototype.neg,\n    multiply:   Complex.prototype.mul,\n    divide:     Complex.prototype.div,\n    pow:        Complex.prototype.pow,\n    factorial() { return math.gamma<any>(this.add(1)); },\n} as const;\n\nnamespace Results {\n    export interface Z {\n        type: \"z\"\n    }\n\n    export interface Constant {\n        type: \"constant\",\n        value: Numeric\n    }\n\n    export interface Method {\n        type: \"method\",\n        f: ComplexMethod<any>\n    }\n    \n    export interface Function {\n        type: \"function\",\n        f: ComplexFunction\n    }\n}\n\ntype LookupResult = Results.Z | Results.Method | Results.Constant;\ntype FoldResult   = Results.Z | Results.Function | Results.Constant;\n\nnamespace ComplexMethod {\n    /**\n     * Checks if this is a valid method on Complex\n     * @param k the method to check\n     * @returns if it is\n     */\n    export function isMethod(k: string): k is keyof Complex {\n        return k in Complex.prototype;\n    }\n\n    /**\n     * Gets a complex method from the given key.\n     * @param k key\n     * @returns a complex method (this will be the prototype method if already a method or a wrapper method if not)\n     */\n    export function get(k: keyof Complex): ComplexMethod<any> {\n        const m = Complex.prototype[k];\n    \n        if (m instanceof Function) return m;\n        return function() { return this[k]; }\n    }\n\n    export function wrap(f: ComplexFunction): ComplexMethod {\n        return function() { return f(this); }\n    }\n}\n\n/**\n * Get a value from a specified object or `undefined` if the key is not present.\n * @param o object\n * @param k key to get\n * @returns value (or `undefined` if not present)\n */\nfunction getFrom<O>(o: O, k: string): O[keyof O] | void {\n    if (k in o) return (o as any)[k];\n}\n\n/**\n * Check if the symbol is in one of the symbol mappings\n * @param n Symbol node to look up\n * @returns the lookup result or an error if not present\n */\nfunction lookup(n: math.SymbolNode): LookupResult {\n    let { name } = n;\n\n    name = name.toLowerCase();\n    if (name === \"z\") return { type: \"z\" };\n\n    if (ComplexMethod.isMethod(name)) return { type: \"method\", f: ComplexMethod.get(name) }\n    if (name in constants) return {\n        type: \"constant\", \n        value: constants[name as keyof typeof constants]\n    }\n    if (name in functions) return {\n        type: \"method\",\n        f: functions[name]\n    }\n\n    throw new Error(`Unrecognized symbol [${name}]`)\n}\n\n/**\n * Take a `FoldResult` object and evaluate it with the specified z-value\n * @param val the `FoldResult`\n * @param z value z should be set to\n * @returns the resulting value\n */\nfunction unwrap(val: FoldResult, z: Complex): Numeric {\n    if (val.type === \"constant\") return val.value;\n    if (val.type === \"function\") return val.f(z);\n    if (val.type === \"z\") return z;\n\n    let _: never = val;\n    throw new Error(`Unrecognized fold result ${(val as any).type}`);\n}\n\nfunction createFunction(\n    f: ComplexMethod<any>, \n    args: math.MathNode[]\n): FoldResult {\n    let fargs = args.map(node => fold(node));\n\n    // if all constants, this can be computed as a constant\n    if (fargs.every((a): a is Results.Constant => a.type === \"constant\")) {\n        const [self, ...rest] = fargs.map(c => c.value);\n\n        const cself = Complex(self);\n        return { type: \"constant\", value: f.apply(cself, rest) };\n    }\n\n    const [self, ...rest] = fargs;\n    \n    return {\n        type: \"function\",\n        f: z => {\n            let a = Complex(unwrap(self, z));\n            let b = rest.map(arg => unwrap(arg, z));\n\n            return f.apply(a, b);\n        }\n    };\n}\n\n/**\n * Fold a node into a usable function\n * @param n Node to fold\n * @returns Function representing the tree\n */\nfunction fold(n: math.MathNode): FoldResult {\n    switch (n.type) {\n        case \"ConstantNode\":\n            return { type: \"constant\", value: n.value };\n        case \"FunctionNode\": {\n            const lk = lookup(n.fn);\n\n            if (lk.type === \"method\") {\n                return createFunction(lk.f, n.args);\n            } else if (lk.type === \"constant\") {\n                throw new Error(`Expected function, got constant [${n.fn.name} = ${lk.value}]`);\n            } else if (lk.type === \"z\") {\n                throw new Error(`Expected function, got [z]`);\n            }\n\n            let _: never = lk;\n            throw new Error(`Expected function, got [${(lk as any).type}]`);\n        }\n        case \"OperatorNode\": {\n            const op = getFrom(operators, n.fn);\n            const f = op ? createFunction(op, n.args) : undefined;\n\n            if (typeof f === \"undefined\") throw new Error(`Unexpected operator [${n.op}]`);\n            return f;\n        }\n        case \"ParenthesisNode\":\n            return fold(n.content);\n        case \"SymbolNode\": {\n            const lk = lookup(n);\n\n            // bare symbols cannot evaluate to methods.\n            if (lk.type === \"method\") {\n                throw new Error(`Unexpected function [${n.name}]`);\n            }\n\n            return lk;\n        }\n        default:\n            throw new Error(`Cannot parse [${n.type}] into complex function`);\n    }\n}\n\n/**\n * Compile a function string into a usable function\n * @param fstr string to compile\n * @returns the function\n */\nexport function compile(fstr: string): Evaluator[\"evaluator\"] {\n    const fr = fold(math.parse(fstr));\n\n    switch (fr.type) {\n        case \"constant\":\n            return {\n                type: \"constant\",\n                f: fr.value,\n            }\n        case \"function\":\n            return fr\n        case \"z\":\n            return {\n                type: \"function\",\n                f: z => z\n            }\n        default:\n            let _: never = fr;\n            throw new Error(`Invalid fold result type ${(fr as any).type}`);\n    }\n}"],"names":["$2DZam","parcelRequire","$209r1","$51JoR","$12abef39f15d4dbb$export$2e2bcd8739ae039","arr","default","$RN0x4","$doFec","i","$ingza","$046ab4fc59af858e$var$ComplexMethod","$046ab4fc59af858e$var$math","$5Ndaw","create","all","$046ab4fc59af858e$var$constants","pi","Complex","PI","e","E","I","inf","INFINITY","infinity","epsilon","EPSILON","nan","NAN","$046ab4fc59af858e$var$functions","gamma","this","ln","prototype","log","$046ab4fc59af858e$var$operators","add","unaryPlus","subtract","sub","unaryMinus","neg","multiply","mul","divide","div","pow","factorial","$046ab4fc59af858e$var$lookup","n","name","toLowerCase","type","isMethod","f","get","value","Error","concat","$046ab4fc59af858e$var$unwrap","val","z","$046ab4fc59af858e$var$createFunction","args","fargs","map","node","$046ab4fc59af858e$var$fold","every","a","ref","c","self","rest","slice","cself","apply","_fargs","self1","rest1","b","arg","lk","fn","op","o","k","$046ab4fc59af858e$var$getFrom","undefined","content","lk1","$046ab4fc59af858e$export$ef7acd7185315e22","fstr","fr","parse","m","Function","wrap","$d0e4415cf369ec6a$var$computeBuffer","ev","cd","chunk","evaluator1","evaluator","inverse","width","height","buf","ArrayBuffer","arr32","Uint32Array","fz","fill","$d0e4415cf369ec6a$var$polarToColor","abs","row","from","length","_","x","y","scale","_center","center","cx","cy","offx","offy","scaleX","scaleY","rx","ry","ref1","nx","ny","$d0e4415cf369ec6a$var$convPlanes","Math","floor","j","offset","set","j1","_loop","rad","theta","r","inv","hue","$d0e4415cf369ec6a$var$mod","h","s","l","g","ref2","ref3","ref4","ref5","ref6","ref7","$d0e4415cf369ec6a$var$hsl2rgb","sqrt","onmessage","data","action","pev","graphID","$d0e4415cf369ec6a$var$buildEvaluator","postMessage","start","performance","now","chunk1","buf1","msg1","console","msg2","time","trunc"],"version":3,"file":"chunkloader.35421398.js.map"}