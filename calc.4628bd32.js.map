{"mappings":"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","sources":["src/taylor2/calc.ts"],"sourcesContent":["import { create, all } from \"mathjs\";\n\nconst math = create(all);\n\nconst X = math.parse(\"x\") as math.SymbolNode;\nconst Y = math.parse(\"y\") as math.SymbolNode;\n\ntype TaylorTerm = [boolean, math.MathNode, number, number]; // coeff sign: true if +, abs coeff, x exp, y exp\ntype TaylorMessage = [string, number, number, number]; // expr, n, a, b\n\nonmessage = function(e) {\n    let dat = e.data as TaylorMessage;\n    postMessage(taylor(...dat));\n}\n\nfunction pascal_row(n: number) {\n    // calculate the coefficients of (x + y)^n\n    return Array.from({length: n + 1}, (_, i) => math.combinations(n, i))\n}\n\nfunction taylorTerms(expr: string, n = 2, a = 0, b = 0): TaylorTerm[] {\n\n    // compute taylor\n    let exprNode: math.MathNode = math.simplify(expr);\n    let approxComponents: TaylorTerm[] = []\n    let order: math.MathNode[] = [] // partials. for n = 3: fxxx, fxxy, fxyy, fyyy\n\n    for (let i = 0; i <= n; i++) {\n        if (order.length == 0) {\n            order = [exprNode];\n        } else {\n            order = [\n                math.derivative(order[0], X),\n                ...order.map(e => math.derivative(e, Y))\n            ];\n        }\n\n        let pascal = pascal_row(i);\n        for (var j = 0; j <= i; j++) {\n            let p = pascal[j];\n            let e = math.simplify(order[j], \n                [...math.simplify.rules,\n                    \"sin(pi / 2) -> 1\",\n                    \"sin(pi) -> 0\",\n                    \"sin(3 * pi / 2) -> -1\",\n                    \"sin(2 * pi) -> 0\",\n\n                    \"cos(pi / 2) -> 0\",\n                    \"cos(pi) -> -1\",\n                    \"cos(3 * pi / 2) -> 0\",\n                    \"cos(2 * pi) -> 1\",\n                    n => n.transform(node => {\n                        if (node.type == \"OperatorNode\" && node.op == \"*\" && !node.implicit) node.implicit = true;\n                        return node;\n                    })\n                ],\n                {x: a, y: b}\n            );\n            let f = math.factorial(i);\n\n            approxComponents.push([...coeff(p, e, f), i - j, j]);\n        }\n    }\n\n    return approxComponents;\n}\n\nconst op = {\n    div(args: math.MathNode[])  { return new math.OperatorNode(\"/\", \"divide\", args)         },\n    imul(args: math.MathNode[]) { return new math.OperatorNode(\"*\", \"multiply\", args, true) },\n    neg(arg: math.MathNode)     { return new math.OperatorNode(\"-\", \"unaryMinus\", [arg])    },\n    add(args: math.MathNode[])  { return new math.OperatorNode(\"+\", \"add\", args)            },\n    sub(args: math.MathNode[])  { return new math.OperatorNode(\"-\", \"subtract\", args)       },\n}\n\nfunction coeff(pascal: number, deriv: math.MathNode, fact: number): [boolean, math.MathNode] {\n    // coeff = (pascal) * (derivative) / factorial\n    \n    let sign = Math.sign(pascal) * Math.sign(fact) >= 0;\n    pascal   = Math.abs(pascal);\n    fact     = Math.abs(fact);\n\n    let pf = op.div([new math.ConstantNode(pascal), new math.ConstantNode(fact)]);\n\n    let prod = math.simplify(op.imul([pf, deriv]), [\n        ...math.simplify.rules, n => n.transform(node => node.type == \"FunctionNode\" ? new math.ConstantNode(node.evaluate()) : node)\n    ]);\n    prod = prod.transform(n => {\n        if (n.type == \"OperatorNode\" && n.fn == \"unaryMinus\") {\n            sign = !sign;\n            return n.args[0];\n        }\n        return n;\n    });\n\n    return [sign, math.simplify(prod)];\n}\nfunction signed(s: boolean, n: math.MathNode) {\n    return s ? n : op.neg(n)\n}\n\nfunction displayTaylor(a: number, b: number, tc: TaylorTerm[]): math.MathNode {\n    let taylorStringComponents = tc.map(([s, c, xe, ye]) => {\n        c = math.simplify(c);\n        if (c.type == \"ConstantNode\" && c.value == 0) return;\n        \n        let args = [];\n\n        if (xe != 0) args.push(math.simplify(`(x - ${a}) ^ ${xe}`));\n        if (ye != 0) args.push(math.simplify(`(y - ${b}) ^ ${ye}`));\n\n        let expr;\n        if (args.length == 0) {\n            return [s, c];\n        } else if (args.length == 1) {\n            expr = args[0];\n        } else {\n            expr = math.simplify(op.imul(args));\n        }\n        \n        if (c.type != \"ConstantNode\" || c.value != 1) {\n            expr = op.imul([c, expr]);\n        }\n\n        return [s, expr];\n    }).filter(x => typeof x !== \"undefined\") as [boolean, math.MathNode][];\n\n    if (taylorStringComponents.length == 0) return new math.ConstantNode(0);\n\n    let first = taylorStringComponents[0];\n    return taylorStringComponents.slice(1)\n        .reduce((acc, [s, n]) => s ? op.add([acc, n]) : op.sub([acc, n]), signed(...first))\n}\n\nfunction taylor(expr: string, n = 2, a = 0, b = 0): string {\n    return displayTaylor(a, b, taylorTerms(expr, n, a, b)).toTex();\n}\n\nexport default taylor;\nexport {TaylorMessage};"],"names":["$6VT6x","parcelRequire","$c185697d0408343e$var$math","$5Ndaw","create","all","$c185697d0408343e$var$X","parse","$c185697d0408343e$var$Y","$c185697d0408343e$var$pascal_row","n","Array","from","length","_","i","combinations","$c185697d0408343e$var$taylorTerms","expr","order","exprNode","derivative","concat","toConsumableArray","map","e","pascal","j","p","e1","simplify","rules","transform","node","type","op","implicit","x","a","y","b","f","factorial","approxComponents","push","$c185697d0408343e$var$coeff","n1","arguments","_loop","onmessage","dat","data","postMessage","$c185697d0408343e$var$taylor","apply","$c185697d0408343e$var$op","args","OperatorNode","arg","deriv","fact","sign","Math","abs","pf","ConstantNode","prod","evaluate","fn","$c185697d0408343e$var$signed","s","$c185697d0408343e$var$displayTaylor","tc","taylorStringComponents","param","_param","c","xe","ye","value","filter","first","slice","reduce","acc","toTex","$c185697d0408343e$export$2e2bcd8739ae039"],"version":3,"file":"calc.4628bd32.js.map"}