{"mappings":"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","sources":["src/snake/snake.ts"],"sourcesContent":["const canvas = document.querySelector('#canvas')! as HTMLCanvasElement;\nconst ctx = canvas.getContext('2d')!;\n\nlet s = 25; // 1 game pixel = s canvas pixels\n\ntype GameCoord = [number, number];\ntype CanvasCoord = [number, number];\nlet [gMaxWidth, gMaxHeight] = toG([canvas.width, canvas.height]);\nlet snake: GameCoord[] = [[Math.floor(gMaxWidth / 4), Math.floor(gMaxHeight / 2)]]; // [head, ..., tail]\nlet facing = 'e'; //n, e, s, w\n\nlet apple: GameCoord;\n\n// CONFIG //\nconst pal = { // color palette\n    bg: '#222',\n    snake: '#0b0',\n    apple: '#d00',\n    death: '#fff',\n}\nsnake.length = 5; // initial snake length\nconst tpu = 75; // ticks per update\n\n\ndrawGRect([0,0], canvas.width, canvas.height, pal.bg, [0, 0]); // draw bg\ndrawGRect(snake[0], s - 2, s - 2, pal.snake); // draw snake\ndrawApple();\nlet int: number | undefined = setInterval(update, tpu);\n\ndocument.onkeydown = e => {\n    switch (e.code) {\n        case 'KeyW':\n        case 'ArrowUp':\n            if (facing != 's' && facing != 'n') {\n                facing = 'n';\n                update();\n            }\n            break;\n        case 'KeyA':\n        case 'ArrowLeft':\n            if (facing != 'e' && facing != 'w') {\n                facing = 'w';\n                update();\n            }\n            break;\n        case 'KeyS':\n        case 'ArrowDown':\n            if (facing != 's' && facing != 'n') {\n                facing = 's';\n                update();\n            }\n            break;\n        case 'KeyD':\n        case 'ArrowRight':\n            if (facing != 'e' && facing != 'w') {\n                facing = 'e';\n                update();\n            }\n            break;\n        case 'KeyR':\n            die()\n            break;\n    }\n};\n\ndocument.onblur = () => {\n    clearInterval(int);\n    int = undefined;\n}\n\ndocument.onfocus = () => {\n    int = int || setInterval(update, tpu);\n}\nfunction drawGRect(g: GameCoord, cw: number, ch: number, color: string, cshift = [1,1]) {\n    let c = toC(g).map((x, i) => x + cshift[i]) as CanvasCoord; // conv g coord and then shift point in c space\n    ctx.fillStyle = color;\n    ctx.fillRect(...c, cw, ch);\n}\n\nfunction drawSnakeSeg(g: GameCoord) {\n    /*\n     * if s = 4,\n     * ........\n     * .xx..xx.\n     * .xx..xx.\n     * ........\n     * o.......\n     * .xx..xx.\n     * .xx..xx.\n     * ........\n     *\n     *\n     *\n     */\n    switch (facing) {\n        case 'n':\n            drawGRect(g, s-2, s, pal.snake)//, [1, 1]);\n            break;    \n        case 'e':\n            drawGRect(g, s, s-2, pal.snake, [-1, 1])//, [-1, 1]);\n            break;\n        case 's':\n            drawGRect(g, s-2, s, pal.snake, [1, -1])//, [1, -1]);\n            break;\n        case 'w':\n            drawGRect(g, s, s-2, pal.snake)//, [1, 1]);\n            break;\n    }\n}\n\nfunction drawApple() {\n    do {\n        apple = [Math.floor(Math.random() * gMaxWidth), Math.floor(Math.random() * gMaxHeight)];\n    } while (snake.some(x => arrEq(x, apple)))\n    drawGRect(apple, s - 2, s - 2, pal.apple); // spawn apple\n}\n\nfunction update() {\n    let nextPos: GameCoord = [...snake[0]]; //clone head\n    switch (facing) {\n        case 'n':\n            nextPos[1]--;\n            break;\n        case 'e':\n            nextPos[0]++;\n            break;\n        case 's':\n            nextPos[1]++;\n            break;\n        case 'w':\n            nextPos[0]--;\n            break;\n    }\n    if(!arrEq(apple, nextPos)) {\n        // if next pos is not apple, delete tail\n        let stail = snake.pop()!;\n        drawGRect(stail, s + 2, s + 2, pal.bg, [-1, -1]);\n    }\n    if(arrEq(apple, nextPos)) drawApple(); // if next pos is apple, spawn a new apple\n    if(arrIncludes(snake, nextPos)) die(); // if next pos is snake, die\n    if (isOutBound(nextPos)) die(); // if next pos is void, die\n    //console.log(nextColor, appleData);\n    snake.unshift(nextPos);\n    drawSnakeSeg(nextPos);\n    document.querySelector('#score')!.textContent = `Score: ${snake.length}`;\n}\n\nfunction die() {\n    clearInterval(int);\n    ctx.fillStyle = pal.death;\n    ctx.font = `${canvas.width * 250 / 700}px 'Comic Sans MS', 'Papyrus', 'Impact', fantasy, cursive, sans-serif`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText('F', canvas.width / 2, canvas.height / 2);\n\n    document.onkeydown = e => e.key == 'r' ? location.reload() : void 0;\n    document.onfocus = null;\n\n    let button = document.createElement('button');\n    button.textContent = 'Restart';\n    button.onclick = () => location.reload();\n    document.querySelector('#score')?.parentElement?.appendChild(button);\n}\n\nfunction toC(g: GameCoord | undefined): CanvasCoord {\n    // converts a game coord to canvas coord\n    return (g ?? [0, 0]).map(x => x * s) as CanvasCoord;\n}\nfunction toG(c: CanvasCoord | undefined): GameCoord {\n    // converts a canvas coord to game coord\n    return (c ?? [0, 0]).map(x => x / s) as GameCoord;\n}\nfunction isOutBound(g: GameCoord) {\n    // game bounds [0, gMaxWidth), [0, gMaxHeight)\n    return g[0] < 0 || g[0] >= gMaxWidth || g[1] < 0 || g[1] >= gMaxHeight;\n}\n\nfunction arrEq<T>(a1: T[], a2: T[]) {\n    return a1.every((x, i) => x == a2[i]);\n}\nfunction arrIncludes<T>(metarr: T[][], arr: T[]) {\n    return metarr.some(a => arrEq(a, arr));\n}\nexport {}"],"names":["c","$947e7a8f6fed5d00$var$apple","$7uoCD","parcelRequire","$947e7a8f6fed5d00$var$canvas","document","querySelector","$947e7a8f6fed5d00$var$ctx","getContext","$947e7a8f6fed5d00$var$s","ref","slicedToArray","width","height","map","x","$947e7a8f6fed5d00$var$gMaxWidth","$947e7a8f6fed5d00$var$gMaxHeight","$947e7a8f6fed5d00$var$snake","Math","floor","$947e7a8f6fed5d00$var$facing","$947e7a8f6fed5d00$var$pal","length","$947e7a8f6fed5d00$var$drawGRect","$947e7a8f6fed5d00$var$drawApple","$947e7a8f6fed5d00$var$int","setInterval","$947e7a8f6fed5d00$var$update","g","cw","ch","color","_ctx","cshift","arguments","$947e7a8f6fed5d00$var$toC","i","fillStyle","fillRect","apply","toConsumableArray","concat","random","some","$947e7a8f6fed5d00$var$arrEq","arr","nextPos","pop","a","$947e7a8f6fed5d00$var$die","unshift","$947e7a8f6fed5d00$var$drawSnakeSeg","textContent","ref2","ref1","clearInterval","font","textAlign","textBaseline","fillText","onkeydown","e","key","location","reload","onfocus","button","createElement","onclick","parentElement","appendChild","a1","a2","every","code","onblur","undefined"],"version":3,"file":"snake.f69e3722.js.map"}