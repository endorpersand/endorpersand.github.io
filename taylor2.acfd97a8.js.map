{"mappings":"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","sources":["src/mvc/taylor2.ts","src/taylor2/display.ts"],"sourcesContent":["import { create, all } from \"mathjs\";\n\nconst math = create(all);\n\nlet x = math.parse(\"x\") as math.SymbolNode;\nlet y = math.parse(\"y\") as math.SymbolNode;\n\ntype TaylorComponents = [number | math.Fraction, number, number][];\ntype TaylorInformation = [number, number, TaylorComponents];\n\nfunction coeffs(n: number) {\n    // calculate the coefficients of (x + y)^n\n    return Array.from({length: n + 1}, (_, i) => math.combinations(n, i))\n}\n\n// def taylor(expr, a = 0, b = 0, h = x, k = y, n = 2):\n//     assert n >= 0\n\n//     approx = 0\n//     order = []\n\n//     for i in range(n + 1):\n//         if len(order) == 0:\n//             order = [expr]\n//         else:\n//             first_order = order[0]\n//             new_order = [diff(first_order, x)]\n//             new_order.extend(diff(e, y) for e in order)\n//             order = new_order\n        \n//         for j, [c, e] in enumerate(zip(all_coeffs(i), order)):\n//             h_term = h ** j if j != 0 else 1\n//             k_term = k ** (i - j) if (i - j) != 0 else 1\n\n//             approx += c * h_term * k_term * e.subs(x, a).subs(y, b) / math.factorial(i)\n        \n//     return approx\n\nfunction taylorComponents(expr: string, n = 2, a = 0, b = 0): TaylorInformation {\n\n    // compute taylor\n    let exprNode: math.MathNode = math.parse(expr);\n    let approxComponents: TaylorComponents = [] // coeff, x exp, y exp\n    let order: math.MathNode[] = []\n\n    for (let i = 0; i <= n; i++) {\n        if (order.length == 0) {\n            order.push(exprNode);\n        } else {\n            let first_order = order[0]\n            let new_order = [math.derivative(first_order, x)];\n            \n            for (let e of order) {\n                new_order.push(math.derivative(e, y));\n            }\n\n            order = new_order;\n        }\n\n        let cs = coeffs(i);\n        for (var j = 0; j <= i; j++) {\n            let c = cs[j];\n            let e = order[j].evaluate({x: a, y: b});\n            let f = math.factorial(i);\n\n            let ee = math.fraction(e);\n            let fullCoeff: number | math.Fraction = math.multiply(math.fraction(c, f), ee) as math.Fraction;\n            approxComponents.push([fullCoeff, i - j, j]);\n        }\n    }\n\n    return [a, b, approxComponents];\n}\n\nfunction stringify(v: number | math.Fraction) {\n    if (math.isInteger(v)) {\n        v = math.number(v) as number;\n    }\n    return math.format(v);\n}\n\nfunction displayTaylor(ti: TaylorInformation): string {\n    let [a, b, tc] = ti;\n    let taylorStringComponents = tc.map(([c, xe, ye]) => {\n        let segs: {h?: math.MathNode, k?: math.MathNode} = {};\n        if (c == 0) return \"0\";\n\n        segs.h = math.parse(`(x - ${a}) ^ ${xe}`);\n        segs.k = math.parse(`(y - ${b}) ^ ${ye}`);\n\n        let expr = math.simplify(\"h * k\", segs);\n\n        let es = expr.toString();\n        if (es === \"1\") {\n            return stringify(c);\n        } else {\n            let coeff;\n            if (c == 1) coeff = \"\";\n            else if (c == -1) coeff = \"-\";\n            else coeff = stringify(c) + \" * \";\n\n            if (expr.type === \"OperatorNode\" && (expr.op === \"+\" || expr.op === \"-\") && coeff !== \"\") {\n                return coeff + `(${es})`;\n            }\n            return coeff + es;\n        }\n    }).filter(x => x != \"0\");\n\n    if (taylorStringComponents.length == 0) return \"0\";\n\n    return taylorStringComponents.reduce((acc, cv) => {\n        let nextTermNeg = cv.startsWith(\"-\");\n\n        if (nextTermNeg) {\n            return `${acc} - ${cv.slice(1)}`;\n        } else {\n            return `${acc} + ${cv}`;\n        }\n    });\n}\n\nfunction taylor(expr: string, n = 2, a = 0, b = 0): string {\n    return displayTaylor(taylorComponents(expr, n, a, b));\n}\n\nexport default taylor;","import { create, all } from \"mathjs\";\nimport taylor from '../mvc/taylor2';\n\ndeclare var MathJax: any;\nconst math = create(all);\ntype MaybeTex = {\n    valid: false,\n    expr: string,\n} | {\n    valid: true,\n    expr: string,\n    tex: string\n};\n\nlet centerDiv = document.querySelector(\"#centerDiv\")!      as HTMLDivElement,\n    [centerX, centerY] = centerDiv.querySelectorAll(\"input\"),\n    funcInput = document.querySelector(\"#func input\")!     as HTMLInputElement,\n    funcTex = document.querySelector(\"#funcTex\")!          as HTMLDivElement,\n    resultTex = document.querySelector(\"#resultTex\")!      as HTMLDivElement,\n    approxNRadio = document.querySelector(\"#appn\")!        as HTMLInputElement,\n    approxNInput = document.querySelector(\"#appninput\")!   as HTMLInputElement,\n    computeButton = document.querySelector(\"#compute\")!    as HTMLButtonElement;\n\nlet tex: MaybeTex = {valid: false, expr: \"\"};\n\ncenterX.addEventListener(\"input\", grayResult);\ncenterY.addEventListener(\"input\", grayResult);\nfuncInput.addEventListener(\"input\", updateFuncTex);\ndocument.querySelectorAll(\"input[name=approx]\").forEach(i => i.addEventListener(\"change\", radioUpdate));\ncomputeButton.addEventListener(\"click\", updateResultTex);\nupdateFuncTex();\nupdateResultTex();\n\nfunction texHandler(node: math.MathNode, options?: object) {\n    if (node.type === \"OperatorNode\" && node.op === \"*\") {\n        let [x, y] = node.args;\n        return `${x.toTex(options)}${y.toTex(options)}`;\n    }\n}\nfunction verifyExpression(expr: string, replEq = \"=\", explicitMul = true): MaybeTex {\n    let fexpr = \"f(x, y) = \" + expr;\n    let tex;\n\n    let options = explicitMul ? {} : {handler: texHandler};\n\n    try {\n        tex = math.parse(fexpr).toTex(options).replace(\":=\", replEq);\n    } catch {\n        return {valid: false, expr}\n    }\n\n    return {valid: true, expr, tex};\n}\n\nfunction findN() {\n    let rads = [...document.querySelectorAll(\"input[name=approx]\")];\n    let v = (rads as HTMLInputElement[])\n        .filter(e => e.checked)\n        .map(e => e.value)[0];\n    \n    if (+v != 0) return +v;\n    return +approxNInput.value;\n}\n\nfunction grayResult() {\n    resultTex.classList.add(\"notCurrentFunc\");\n}\n\nfunction updateTex() {\n    if (\"typeset\" in MathJax) {\n        MathJax.typeset();\n    }\n}\n\nfunction updateFuncTex() {\n    tex = verifyExpression(funcInput.value);\n\n    if (tex.valid) {\n        funcTex.innerHTML = `$$${tex.tex}$$`;\n    } else {\n        funcTex.innerHTML = `$$\\\\color{red}{?}$$`\n    }\n\n    grayResult();\n    updateTex();\n}\n\nfunction updateResultTex() {\n    let succ = false;\n    if (tex.valid) {\n        let taytay: string = \"\";\n        resultTex.classList.remove(\"err\");\n        resultTex.classList.remove(\"notCurrentFunc\");\n        try {\n            taytay = taylor(tex.expr, findN(), +centerX.value, +centerY.value);\n        } catch (e) {\n            console.log(e);\n            if (e instanceof Error && e.message.startsWith(\"Undefined \")) {\n                let msg = e.message;\n                let sym = msg.slice(\"Undefined symbol \".length); // can also be \"Undefined function\", but not that big of a deal\n                if (sym.includes(\"x\") || sym.includes(\"y\")) {\n                    msg += \" (try adding * here?)\"\n                }\n                resultTex.innerHTML = msg;\n                resultTex.classList.add(\"err\");\n                return;\n            }\n        }\n        let rTex = verifyExpression(taytay, \"\\\\approx\", false);\n        if (rTex.valid) {\n            resultTex.innerHTML = `$$${rTex.tex}$$`;\n            succ = true;\n        }\n    }\n    if (!succ) {\n        resultTex.innerHTML = `$$\\\\color{red}{?}$$`\n    }\n    updateTex();\n}\n\nfunction radioUpdate() {\n    approxNInput.disabled = !approxNRadio.checked;\n    grayResult();\n}"],"names":["$1800b820808e1fb4$var$math","create","$ghe96","all","$1800b820808e1fb4$var$x","parse","$1800b820808e1fb4$var$y","$1800b820808e1fb4$var$coeffs","n","Array","from","length","_","i","combinations","$1800b820808e1fb4$var$stringify","v","isInteger","number","format","$1800b820808e1fb4$export$2e2bcd8739ae039","expr","a","b","ti","tc","taylorStringComponents","map","c","xe","ye","segs","h","k","simplify","es","toString","coeff","type","op","filter","x","reduce","acc","cv","startsWith","slice","$1800b820808e1fb4$var$displayTaylor","exprNode","approxComponents","order","push","first_order","new_order","derivative","e","cs","j","evaluate","y","f","factorial","ee","fraction","fullCoeff","multiply","$1800b820808e1fb4$var$taylorComponents","$7eb4b9aeefed061a$var$math","$7eb4b9aeefed061a$var$centerDiv","document","querySelector","$7eb4b9aeefed061a$var$centerX","$7eb4b9aeefed061a$var$centerY","querySelectorAll","$7eb4b9aeefed061a$var$funcInput","$7eb4b9aeefed061a$var$funcTex","$7eb4b9aeefed061a$var$resultTex","$7eb4b9aeefed061a$var$approxNRadio","$7eb4b9aeefed061a$var$approxNInput","$7eb4b9aeefed061a$var$computeButton","$7eb4b9aeefed061a$var$tex","valid","$7eb4b9aeefed061a$var$texHandler","node","options","args","toTex","$7eb4b9aeefed061a$var$verifyExpression","replEq","explicitMul","tex","fexpr","handler","replace","$7eb4b9aeefed061a$var$grayResult","classList","add","$7eb4b9aeefed061a$var$updateTex","MathJax","typeset","$7eb4b9aeefed061a$var$updateFuncTex","value","innerHTML","$7eb4b9aeefed061a$var$updateResultTex","succ","taytay","remove","checked","$7eb4b9aeefed061a$var$findN","console","log","Error","message","msg","sym","includes","rTex","$7eb4b9aeefed061a$var$radioUpdate","disabled","addEventListener","forEach"],"version":3,"file":"taylor2.acfd97a8.js.map"}