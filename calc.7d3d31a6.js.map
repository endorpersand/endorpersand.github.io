{"mappings":"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","sources":["src/taylor2/calc.ts"],"sourcesContent":["import { create, all } from \"mathjs\";\n\nconst math = create(all);\n\nconst X = math.parse(\"x\") as math.SymbolNode;\nconst Y = math.parse(\"y\") as math.SymbolNode;\n\ntype TaylorTerm = [boolean, math.MathNode, number, number]; // coeff sign: true if +, abs coeff, x exp, y exp\ntype TaylorMessage = [string, number, number, number]; // expr, n, a, b\n\nonmessage = function(e) {\n    let dat = e.data as TaylorMessage;\n    postMessage(taylor(...dat));\n}\n\nfunction pascal_row(n: number) {\n    // calculate the coefficients of (x + y)^n\n    return Array.from({length: n + 1}, (_, i) => math.combinations(n, i))\n}\n\nfunction taylorTerms(expr: string, n = 2, a = 0, b = 0): TaylorTerm[] {\n\n    // compute taylor\n    let exprNode: math.MathNode = math.simplify(expr);\n    let approxComponents: TaylorTerm[] = []\n    let order: math.MathNode[] = [] // partials. for n = 3: fxxx, fxxy, fxyy, fyyy\n\n    for (let i = 0; i <= n; i++) {\n        if (order.length == 0) {\n            order = [exprNode];\n        } else {\n            order = [\n                math.derivative(order[0], X),\n                ...order.map(e => math.derivative(e, Y))\n            ];\n        }\n\n        let pascal = pascal_row(i);\n        for (var j = 0; j <= i; j++) {\n            let p = pascal[j];\n            let e = math.simplify(order[j], \n                [...math.simplify.rules,\n                    \"sin(pi / 2) -> 1\",\n                    \"sin(pi) -> 0\",\n                    \"sin(3 * pi / 2) -> -1\",\n                    \"sin(2 * pi) -> 0\",\n\n                    \"cos(pi / 2) -> 0\",\n                    \"cos(pi) -> -1\",\n                    \"cos(3 * pi / 2) -> 0\",\n                    \"cos(2 * pi) -> 1\",\n                    n => n.transform(node => {\n                        if (node.type == \"OperatorNode\" && node.op == \"*\" && !node.implicit) node.implicit = true;\n                        return node;\n                    })\n                ],\n                {x: a, y: b}\n            );\n            let f = math.factorial(i);\n\n            approxComponents.push([...coeff(p, e, f), i - j, j]);\n        }\n    }\n\n    return approxComponents;\n}\n\nconst op = {\n    div(args: math.MathNode[])  { return new math.OperatorNode(\"/\", \"divide\", args)         },\n    imul(args: math.MathNode[]) { return new math.OperatorNode(\"*\", \"multiply\", args, true) },\n    neg(arg: math.MathNode)     { return new math.OperatorNode(\"-\", \"unaryMinus\", [arg])    },\n    add(args: math.MathNode[])  { return new math.OperatorNode(\"+\", \"add\", args)            },\n    sub(args: math.MathNode[])  { return new math.OperatorNode(\"-\", \"subtract\", args)       },\n}\n\nfunction coeff(pascal: number, deriv: math.MathNode, fact: number): [boolean, math.MathNode] {\n    // coeff = (pascal) * (derivative) / factorial\n    \n    let sign = Math.sign(pascal) * Math.sign(fact) >= 0;\n    pascal   = Math.abs(pascal);\n    fact     = Math.abs(fact);\n\n    let pf = op.div([new math.ConstantNode(pascal), new math.ConstantNode(fact)]);\n\n    let prod = math.simplify(op.imul([pf, deriv]), [\n        ...math.simplify.rules, n => n.transform(node => node.type == \"FunctionNode\" ? new math.ConstantNode(node.evaluate()) : node)\n    ]);\n    prod = prod.transform(n => {\n        if (n.type == \"OperatorNode\" && n.fn == \"unaryMinus\") {\n            sign = !sign;\n            return n.args[0];\n        }\n        return n;\n    });\n\n    return [sign, math.simplify(prod)];\n}\nfunction signed(s: boolean, n: math.MathNode) {\n    return s ? n : op.neg(n)\n}\n\nfunction displayTaylor(a: number, b: number, tc: TaylorTerm[]): math.MathNode {\n    let taylorStringComponents = tc.map(([s, c, xe, ye]) => {\n        c = math.simplify(c);\n        if (c.type == \"ConstantNode\" && c.value == 0) return;\n        \n        let args = [];\n\n        if (xe != 0) args.push(math.simplify(`(x - ${a}) ^ ${xe}`));\n        if (ye != 0) args.push(math.simplify(`(y - ${b}) ^ ${ye}`));\n\n        let expr;\n        if (args.length == 0) {\n            return [s, c];\n        } else if (args.length == 1) {\n            expr = args[0];\n        } else {\n            expr = math.simplify(op.imul(args));\n        }\n        \n        if (c.type != \"ConstantNode\" || c.value != 1) {\n            expr = op.imul([c, expr]);\n        }\n\n        return [s, expr];\n    }).filter(x => typeof x !== \"undefined\") as [boolean, math.MathNode][];\n\n    if (taylorStringComponents.length == 0) return new math.ConstantNode(0);\n\n    let first = taylorStringComponents[0];\n    return taylorStringComponents.slice(1)\n        .reduce((acc, [s, n]) => s ? op.add([acc, n]) : op.sub([acc, n]), signed(...first))\n}\n\nfunction taylor(expr: string, n = 2, a = 0, b = 0): string {\n    return displayTaylor(a, b, taylorTerms(expr, n, a, b)).toTex();\n}\n\nexport default taylor;\nexport {TaylorMessage};"],"names":["$2DZam","parcelRequire","$c185697d0408343e$var$math","$5Ndaw","create","all","$c185697d0408343e$var$X","parse","$c185697d0408343e$var$Y","$c185697d0408343e$var$pascal_row","n","Array","from","length","_","i","combinations","$c185697d0408343e$var$taylorTerms","expr","order","exprNode","derivative","concat","$Tzw6x","default","map","e","pascal","j","p","e1","simplify","rules","transform","node","type","op","implicit","x","a","y","b","f","factorial","approxComponents","push","$c185697d0408343e$var$coeff","n1","arguments","i1","_loop","onmessage","dat","data","postMessage","$c185697d0408343e$var$taylor","apply","$c185697d0408343e$var$op","args","OperatorNode","arg","deriv","fact","sign","Math","abs","pf","ConstantNode","prod","evaluate","fn","$c185697d0408343e$var$signed","s","$c185697d0408343e$var$displayTaylor","tc","taylorStringComponents","param","_param","c","xe","ye","value","filter","first","slice","reduce","acc","toTex","$c185697d0408343e$export$2e2bcd8739ae039"],"version":3,"file":"calc.7d3d31a6.js.map"}