{"mappings":"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","sources":["src/mvc/taylor2.ts","src/taylor2/display.ts"],"sourcesContent":["import { create, all } from \"mathjs\";\n\nconst math = create(all);\n\nlet x = math.parse(\"x\") as math.SymbolNode;\nlet y = math.parse(\"y\") as math.SymbolNode;\n\ntype TaylorComponents = [number | math.Fraction, number, number][];\ntype TaylorInformation = [number, number, TaylorComponents];\n\nfunction coeffs(n: number) {\n    // calculate the coefficients of (x + y)^n\n    return Array.from({length: n + 1}, (_, i) => math.combinations(n, i))\n}\n\n// def taylor(expr, a = 0, b = 0, h = x, k = y, n = 2):\n//     assert n >= 0\n\n//     approx = 0\n//     order = []\n\n//     for i in range(n + 1):\n//         if len(order) == 0:\n//             order = [expr]\n//         else:\n//             first_order = order[0]\n//             new_order = [diff(first_order, x)]\n//             new_order.extend(diff(e, y) for e in order)\n//             order = new_order\n        \n//         for j, [c, e] in enumerate(zip(all_coeffs(i), order)):\n//             h_term = h ** j if j != 0 else 1\n//             k_term = k ** (i - j) if (i - j) != 0 else 1\n\n//             approx += c * h_term * k_term * e.subs(x, a).subs(y, b) / math.factorial(i)\n        \n//     return approx\n\nfunction taylorComponents(expr: string, n = 2, a = 0, b = 0): TaylorInformation {\n\n    // compute taylor\n    let exprNode: math.MathNode = math.parse(expr);\n    let approxComponents: TaylorComponents = [] // coeff, x exp, y exp\n    let order: math.MathNode[] = []\n\n    for (let i = 0; i <= n; i++) {\n        if (order.length == 0) {\n            order.push(exprNode);\n        } else {\n            let first_order = order[0]\n            let new_order = [math.derivative(first_order, x)];\n            \n            for (let e of order) {\n                new_order.push(math.derivative(e, y));\n            }\n\n            order = new_order;\n        }\n\n        let cs = coeffs(i);\n        for (var j = 0; j <= i; j++) {\n            let c = cs[j];\n            let e = order[j].evaluate({x: a, y: b});\n            let f = math.factorial(i);\n\n            let ee = math.fraction(e);\n            let fullCoeff: number | math.Fraction = math.multiply(math.fraction(c, f), ee) as math.Fraction;\n            approxComponents.push([fullCoeff, i - j, j]);\n        }\n    }\n\n    return [a, b, approxComponents];\n}\n\nfunction stringify(v: number | math.Fraction) {\n    if (math.isInteger(v)) {\n        v = math.number(v) as number;\n    }\n    return math.format(v);\n}\n\nfunction displayTaylor(ti: TaylorInformation): string {\n    let [a, b, tc] = ti;\n    let taylorStringComponents = tc.map(([c, xe, ye]) => {\n        let segs: {h?: math.MathNode, k?: math.MathNode} = {};\n        if (c == 0) return \"0\";\n\n        segs.h = math.parse(`(x - ${a}) ^ ${xe}`);\n        segs.k = math.parse(`(y - ${b}) ^ ${ye}`);\n\n        let expr = math.simplify(\"h * k\", segs);\n\n        let es = expr.toString();\n        if (es === \"1\") {\n            return stringify(c);\n        } else {\n            let coeff;\n            if (c == 1) coeff = \"\";\n            else if (c == -1) coeff = \"-\";\n            else coeff = stringify(c) + \" * \";\n\n            return coeff + es;\n        }\n    }).filter(x => x != \"0\");\n\n    if (taylorStringComponents.length == 0) return \"0\";\n\n    return taylorStringComponents.reduce((acc, cv) => {\n        let nextTermNeg = cv.startsWith(\"-\");\n\n        if (nextTermNeg) {\n            return `${acc} - ${cv.slice(1)}`;\n        } else {\n            return `${acc} + ${cv}`;\n        }\n    });\n}\n\nfunction taylor(expr: string, n = 2, a = 0, b = 0): string {\n    return displayTaylor(taylorComponents(expr, n, a, b));\n}\n\nexport default taylor;","import { create, all } from \"mathjs\";\nimport taylor from '../mvc/taylor2';\n\ndeclare var MathJax: any;\nconst math = create(all);\ntype MaybeTex = {\n    valid: false,\n    expr: string,\n} | {\n    valid: true,\n    expr: string,\n    tex: string\n};\n\nlet centerDiv = document.querySelector(\"#centerDiv\")!      as HTMLDivElement,\n    [centerX, centerY] = centerDiv.querySelectorAll(\"input\"),\n    funcInput = document.querySelector(\"#func input\")!     as HTMLInputElement,\n    funcTex = document.querySelector(\"#funcTex\")!          as HTMLDivElement,\n    resultTex = document.querySelector(\"#resultTex\")!      as HTMLDivElement,\n    approxNRadio = document.querySelector(\"#appn\")!        as HTMLInputElement,\n    approxNInput = document.querySelector(\"#appninput\")!   as HTMLInputElement,\n    computeButton = document.querySelector(\"#compute\")!    as HTMLButtonElement;\n\nlet tex: MaybeTex = {valid: false, expr: \"\"};\n\ncenterX.addEventListener(\"input\", grayResult);\ncenterY.addEventListener(\"input\", grayResult);\nfuncInput.addEventListener(\"input\", updateFuncTex);\ndocument.querySelectorAll(\"input[name=approx]\").forEach(i => i.addEventListener(\"change\", radioUpdate));\ncomputeButton.addEventListener(\"click\", updateResultTex);\nupdateFuncTex();\nupdateResultTex();\n\nfunction texHandler(node: math.MathNode, options?: object) {\n    if (node.type === \"OperatorNode\" && node.op === \"*\") {\n        let [x, y] = node.args;\n        return `${x.toTex(options)}${y.toTex(options)}`;\n    }\n}\nfunction verifyExpression(expr: string, replEq = \"=\", explicitMul = true): MaybeTex {\n    let fexpr = \"f(x, y) = \" + expr;\n    let tex;\n\n    let options = explicitMul ? {} : {handler: texHandler};\n\n    try {\n        tex = math.parse(fexpr).toTex(options).replace(\":=\", replEq);\n    } catch {\n        return {valid: false, expr}\n    }\n\n    return {valid: true, expr, tex};\n}\n\nfunction findN() {\n    let rads = [...document.querySelectorAll(\"input[name=approx]\")];\n    let v = (rads as HTMLInputElement[])\n        .filter(e => e.checked)\n        .map(e => e.value)[0];\n    \n    if (+v != 0) return +v;\n    return +approxNInput.value;\n}\n\nfunction grayResult() {\n    resultTex.classList.add(\"notCurrentFunc\");\n}\n\nfunction updateTex() {\n    if (\"typeset\" in MathJax) {\n        MathJax.typeset();\n    }\n}\n\nfunction updateFuncTex() {\n    tex = verifyExpression(funcInput.value);\n\n    if (tex.valid) {\n        funcTex.innerHTML = `$$${tex.tex}$$`;\n    } else {\n        funcTex.innerHTML = `$$\\\\color{red}{?}$$`\n    }\n\n    grayResult();\n    updateTex();\n}\n\nfunction updateResultTex() {\n    let succ = false;\n    if (tex.valid) {\n        let taytay: string = \"\";\n        resultTex.classList.remove(\"err\");\n        resultTex.classList.remove(\"notCurrentFunc\");\n        try {\n            taytay = taylor(tex.expr, findN(), +centerX.value, +centerY.value);\n        } catch (e) {\n            console.log(e);\n            if (e instanceof Error && e.message.startsWith(\"Undefined \")) {\n                let msg = e.message;\n                let sym = msg.slice(\"Undefined symbol \".length); // can also be \"Undefined function\", but not that big of a deal\n                if (sym.includes(\"x\") || sym.includes(\"y\")) {\n                    msg += \" (try adding * here?)\"\n                }\n                resultTex.innerHTML = msg;\n                resultTex.classList.add(\"err\");\n                return;\n            }\n        }\n        let rTex = verifyExpression(taytay, \"\\\\approx\", false);\n        if (rTex.valid) {\n            resultTex.innerHTML = `$$${rTex.tex}$$`;\n            succ = true;\n        }\n    }\n    if (!succ) {\n        resultTex.innerHTML = `$$\\\\color{red}{?}$$`\n    }\n    updateTex();\n}\n\nfunction radioUpdate() {\n    approxNInput.disabled = !approxNRadio.checked;\n    grayResult();\n}"],"names":["$1800b820808e1fb4$var$math","create","$ghe96","all","$1800b820808e1fb4$var$x","parse","$1800b820808e1fb4$var$y","$1800b820808e1fb4$var$coeffs","n","Array","from","length","_","i","combinations","$1800b820808e1fb4$var$stringify","v","isInteger","number","format","$1800b820808e1fb4$export$2e2bcd8739ae039","expr","a","b","ti","tc","taylorStringComponents","map","c","xe","ye","segs","h","k","es","simplify","toString","coeff","filter","x","reduce","acc","cv","startsWith","slice","$1800b820808e1fb4$var$displayTaylor","exprNode","approxComponents","order","push","first_order","new_order","derivative","e","cs","j","evaluate","y","f","factorial","ee","fraction","fullCoeff","multiply","$1800b820808e1fb4$var$taylorComponents","$7eb4b9aeefed061a$var$math","$7eb4b9aeefed061a$var$centerDiv","document","querySelector","$7eb4b9aeefed061a$var$centerX","$7eb4b9aeefed061a$var$centerY","querySelectorAll","$7eb4b9aeefed061a$var$funcInput","$7eb4b9aeefed061a$var$funcTex","$7eb4b9aeefed061a$var$resultTex","$7eb4b9aeefed061a$var$approxNRadio","$7eb4b9aeefed061a$var$approxNInput","$7eb4b9aeefed061a$var$computeButton","$7eb4b9aeefed061a$var$tex","valid","$7eb4b9aeefed061a$var$texHandler","node","options","type","op","args","toTex","$7eb4b9aeefed061a$var$verifyExpression","replEq","explicitMul","tex","fexpr","handler","replace","$7eb4b9aeefed061a$var$grayResult","classList","add","$7eb4b9aeefed061a$var$updateTex","MathJax","typeset","$7eb4b9aeefed061a$var$updateFuncTex","value","innerHTML","$7eb4b9aeefed061a$var$updateResultTex","succ","taytay","remove","checked","$7eb4b9aeefed061a$var$findN","console","log","Error","message","msg","sym","includes","rTex","$7eb4b9aeefed061a$var$radioUpdate","disabled","addEventListener","forEach"],"version":3,"file":"taylor2.01679d32.js.map"}