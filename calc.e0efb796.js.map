{"mappings":"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","sources":["src/taylor2/calc.ts"],"sourcesContent":["import { create, all } from \"mathjs\";\n\nconst math = create(all);\n\nconst X = math.parse(\"x\") as math.SymbolNode;\nconst Y = math.parse(\"y\") as math.SymbolNode;\n\ntype TaylorTerm = [boolean, math.MathNode, number, number]; // coeff sign: true if +, abs coeff, x exp, y exp\ntype TaylorMessage = [string, number, number, number]; // expr, n, a, b\n\nonmessage = function(e) {\n    let dat = e.data as TaylorMessage;\n    postMessage(taylor(...dat));\n}\n\nfunction pascal_row(n: number) {\n    // calculate the coefficients of (x + y)^n\n    return Array.from({length: n + 1}, (_, i) => math.combinations(n, i))\n}\n\nfunction taylorTerms(expr: string, n = 2, a = 0, b = 0): TaylorTerm[] {\n\n    // compute taylor\n    let exprNode: math.MathNode = math.simplify(expr);\n    let approxComponents: TaylorTerm[] = []\n    let order: math.MathNode[] = [] // partials. for n = 3: fxxx, fxxy, fxyy, fyyy\n\n    for (let i = 0; i <= n; i++) {\n        if (order.length == 0) {\n            order = [exprNode];\n        } else {\n            let first_order = order[0]\n            let new_order = [math.derivative(first_order, X)];\n            \n            for (let e of order) {\n                new_order.push(math.derivative(e, Y));\n            }\n\n            order = new_order;\n        }\n\n        let pascal = pascal_row(i);\n        for (var j = 0; j <= i; j++) {\n            let p = pascal[j];\n            let e = math.simplify(order[j], \n                [...math.simplify.rules,\n                    \"sin(pi / 2) -> 1\",\n                    \"sin(pi) -> 0\",\n                    \"sin(3 * pi / 2) -> -1\",\n                    \"sin(2 * pi) -> 0\",\n\n                    \"cos(pi / 2) -> 0\",\n                    \"cos(pi) -> -1\",\n                    \"cos(3 * pi / 2) -> 0\",\n                    \"cos(2 * pi) -> 1\",\n                    n => n.transform(node => {\n                        if (node.type == \"OperatorNode\" && node.op == \"*\" && !node.implicit) node.implicit = true;\n                        return node;\n                    })\n                ],\n                {x: a, y: b}\n            );\n            let f = math.factorial(i);\n\n            approxComponents.push([...coeff(p, e, f), i - j, j]);\n        }\n    }\n\n    return approxComponents;\n}\n\nconst op = {\n    div(args: math.MathNode[])  { return new math.OperatorNode(\"/\", \"divide\", args)         },\n    imul(args: math.MathNode[]) { return new math.OperatorNode(\"*\", \"multiply\", args, true) },\n    neg(arg: math.MathNode)     { return new math.OperatorNode(\"-\", \"unaryMinus\", [arg])    },\n    add(args: math.MathNode[])  { return new math.OperatorNode(\"+\", \"add\", args)            },\n    sub(args: math.MathNode[])  { return new math.OperatorNode(\"-\", \"subtract\", args)       },\n}\n\nfunction coeff(pascal: number, deriv: math.MathNode, fact: number): [boolean, math.MathNode] {\n    // coeff = (pascal) * (derivative) / factorial\n    \n    let sign = Math.sign(pascal) * Math.sign(fact) >= 0;\n    pascal   = Math.abs(pascal);\n    fact     = Math.abs(fact);\n\n    let pf = op.div([new math.ConstantNode(pascal), new math.ConstantNode(fact)]);\n\n    let prod = math.simplify(op.imul([pf, deriv]), [\n        ...math.simplify.rules, n => n.transform(node => node.type == \"FunctionNode\" ? new math.ConstantNode(node.evaluate()) : node)\n    ]);\n    prod = prod.transform(n => {\n        if (n.type == \"OperatorNode\" && n.fn == \"unaryMinus\") {\n            sign = !sign;\n            return n.args[0];\n        }\n        return n;\n    });\n\n    return [sign, math.simplify(prod)];\n}\nfunction signed(s: boolean, n: math.MathNode) {\n    return s ? n : op.neg(n)\n}\n\nfunction displayTaylor(a: number, b: number, tc: TaylorTerm[]): math.MathNode {\n    let taylorStringComponents = tc.map(([s, c, xe, ye]) => {\n        c = math.simplify(c);\n        if (c.type == \"ConstantNode\" && c.value == 0) return;\n        \n        let args = [];\n\n        if (xe != 0) args.push(math.simplify(`(x - ${a}) ^ ${xe}`));\n        if (ye != 0) args.push(math.simplify(`(y - ${b}) ^ ${ye}`));\n\n        let expr;\n        if (args.length == 0) {\n            return [s, c];\n        } else if (args.length == 1) {\n            expr = args[0];\n        } else {\n            expr = math.simplify(op.imul(args));\n        }\n        \n        if (c.type != \"ConstantNode\" || c.value != 1) {\n            expr = op.imul([c, expr]);\n        }\n\n        return [s, expr];\n    }).filter(x => typeof x !== \"undefined\") as [boolean, math.MathNode][];\n\n    if (taylorStringComponents.length == 0) return new math.ConstantNode(0);\n\n    let first = taylorStringComponents[0];\n    return taylorStringComponents.slice(1)\n        .reduce((acc, [s, n]) => s ? op.add([acc, n]) : op.sub([acc, n]), signed(...first))\n}\n\nfunction taylor(expr: string, n = 2, a = 0, b = 0): string {\n    return displayTaylor(a, b, taylorTerms(expr, n, a, b)).toTex();\n}\n\nexport default taylor;\nexport {TaylorMessage};"],"names":["$027f3","parcelRequire","$c185697d0408343e$var$math","$6neD6","create","all","$c185697d0408343e$var$X","parse","$c185697d0408343e$var$Y","$c185697d0408343e$var$pascal_row","n","Array","from","length","_","i","combinations","$c185697d0408343e$var$taylorTerms","expr","n1","arguments","a","b","exprNode","simplify","approxComponents","order","first_order","new_order","derivative","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","e","value","push","err","return","pascal","j","p","e1","$parcel$interopDefault","$6McDW","rules","concat","transform","node","type","op","implicit","x","y","f","factorial","$c185697d0408343e$var$coeff","onmessage","dat","data","postMessage","$c185697d0408343e$var$taylor","apply","$c185697d0408343e$var$op","args","OperatorNode","arg","deriv","fact","sign","Math","abs","pf","ConstantNode","prod","evaluate","fn","$c185697d0408343e$var$signed","s","$c185697d0408343e$var$displayTaylor","tc","taylorStringComponents","map","param","_param","c","xe","ye","filter","first","slice","reduce","acc","toTex","$c185697d0408343e$export$2e2bcd8739ae039"],"version":3,"file":"calc.e0efb796.js.map"}