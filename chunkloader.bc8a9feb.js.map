{"mappings":"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","sources":["src/complexgrapher/worker/chunkloader.ts","src/complexgrapher/types.ts","node_modules/.pnpm/@swc+helpers@0.4.3/node_modules/@swc/helpers/src/_to_array.mjs","src/complexgrapher/evaluator.ts"],"sourcesContent":["import { Complex, CanvasData, ChunkData, PartialEvaluator, Evaluator, LoaderIn, LoaderOut, MainIn, InitIn, ComplexFunction, MainOut } from \"../types\";\nimport * as evaluator from \"../evaluator\";\n\nconst resolution = 1;\n\nonmessage = function (e: MessageEvent<InitIn | MainIn | LoaderIn>) {\n    let data = e.data;\n\n    if (data.action === \"init\") {\n        self.postMessage({action: \"ready\"});\n        return;\n    }\n\n    let { pev, cd, graphID } = data;\n    let ev = buildEvaluator(pev);\n\n    if (data.action === \"chunkRequest\") {\n        let chunk = data.chunk;\n\n        let buf = computeBuffer(ev, cd, chunk);\n        let msg: LoaderOut = { action: \"chunkDone\", buf, chunk, graphID };\n        postMessage(msg, [buf] as any);\n    } else if (data.action === \"mainRequest\") {\n        const start = performance.now();\n\n        // TODO, use like actual methods here.\n        for (let i = 0; i < cd.width; i += 100) {\n            for (let j = 0; j < cd.height; j += 100) {\n                let chunk = { width: 100, height: 100, offx: i, offy: j };\n                let buf = computeBuffer(ev, cd, chunk);\n\n                let msg: LoaderOut = { action: \"chunkDone\", buf, chunk, graphID };\n                postMessage(msg, [buf] as any);\n                console.log(msg);\n            }\n        }\n\n        let msg: MainOut = {action: \"done\", time: Math.trunc(performance.now() - start), graphID};\n        postMessage(msg);\n    } else {\n        let _: never = data;\n        throw new Error(\"Unrecognized request into chunkLoader\");\n    }\n}\n\n/**\n * Take a partially computed evaluator and fully evaluate it.\n * @param pev partially computed evaluator\n * @returns the full evaluator\n */\nfunction buildEvaluator(pev: PartialEvaluator): Evaluator {\n    let {fstr, inverse} = pev;\n    return {evaluator: evaluator.compile(fstr), inverse}\n}\n\n/**\n * Compute the ArrayBuffer for the chunk\n * @param ev The function evaluator\n * @param cd Canvas dimension data\n * @param chunk Chunk position and size\n * @returns the computed chunk\n */\nfunction computeBuffer(ev: Evaluator, cd: CanvasData, chunk: ChunkData): ArrayBuffer {\n    let {evaluator, inverse} = ev;\n    let {width, height} = chunk;\n\n    let buf = new ArrayBuffer(4 * width * height);\n    let arr32 = new Uint32Array(buf);\n\n    if (evaluator.type === \"constant\") {\n        const fz = Complex(evaluator.f);\n        arr32.fill( polarToColor(fz.abs(), fz.arg(), inverse) );\n    } else {\n        const { f } = evaluator;\n        \n        for (var j = 0; j < height; j += resolution) {\n            const row = Uint32Array.from({length: width}, (_, i) => {\n                // compute value\n                let fz: Complex = Complex(f( convPlanes(Math.floor(i / resolution) * resolution, j, cd, chunk) ));\n    \n                let r = fz.abs();\n                let phi = fz.arg();\n\n                return polarToColor(r, phi, inverse);\n            });\n            \n            for (let k = 0; k < resolution && (j + k) < height; k++) {\n                const offset = (j + k) * width;\n                arr32.set(row, offset);\n            }\n        }\n    }\n\n    return buf;\n}\n\n/**\n  * Converts xy canvas pixels to values in the complex plane\n * @param x x coord\n * @param y y coord\n * @param cd canvas data\n * @param chunk chunk offset data\n * @returns the complex value associated\n */\nfunction convPlanes(x: number, y: number, cd: CanvasData, chunk: ChunkData) {\n    const { width, height, scale, center: [cx, cy] } = cd;\n    const { offx, offy } = chunk;\n    const scaleX = scale * width / height;\n    const scaleY = scale;\n\n    // distance of each radius\n    let [rx, ry] = [\n        (width  - 1) / 2,\n        (height - 1) / 2\n    ];\n\n    // normalized distance from center (This means the center is at 0, the edges are at ±1).\n    // the center is also (rx, ry)\n    let [nx, ny] = [\n         (x + offx - rx) / rx, \n        -(y + offy - ry) / ry\n    ];\n    \n    return Complex(cx + nx * scaleX, cy + ny * scaleY);\n}\n\n/**\n * Takes a polar coordinate and maps it to a color\n * @param rad Radius\n * @param theta Angle\n * @param inverse Whether to invert the brightness\n * @returns the associated color in RGB\n */\nfunction polarToColor(rad: number, theta: number, inverse: boolean) {\n    let hue = mod(theta * 3 / Math.PI, 6); // hue [0,6)\n    if (inverse) hue = 6 - hue;\n\n    return hsl2rgb(\n        hue,\n        1,\n        bfunc(rad, inverse),\n    );\n}\n\n/**\n * Converts HSL to RGBA\n * @param h hue [0, 6]\n * @param s saturation [0, 1]\n * @param l lightness [0, 1]\n * @returns 4-byte RGBA number ([0, 255], alpha is always 255)\n */\nfunction hsl2rgb(h: number, s: number, l: number) {\n    let c, x, m, r, g, b;\n    c = (1 - Math.abs(2 * l - 1)) * s;\n    x = c * (1 - Math.abs(mod(h, 2) - 1));\n    m = l - c / 2;\n    if (0 <= h && h < 1) [r, g, b] = [c, x, 0];\n    else if (1 <= h && h < 2) [r, g, b] = [x, c, 0];\n    else if (2 <= h && h < 3) [r, g, b] = [0, c, x];\n    else if (3 <= h && h < 4) [r, g, b] = [0, x, c];\n    else if (4 <= h && h < 5) [r, g, b] = [x, 0, c];\n    else if (5 <= h && h < 6) [r, g, b] = [c, 0, x];\n    else [r, g, b] = [c, x, 0];\n\n    return (    0xFF  << 24) | \n    (((b + m) * 0xFF) << 16) |\n    (((g + m) * 0xFF) <<  8) |\n     ((r + m) * 0xFF);\n}\n\n/**\n * Brightness computation\n * @param r Radius\n * @param inv Whether to invert the brightness\n * @returns the brightness as float\n */\nfunction bfunc(r: number, inv: boolean) {\n    // bfunc needs to match the identities:\n    // b(1/x) = 1 - b(x)\n    // b(0) = 0\n\n    // the current impl uses b(x) = 1 - 1/(x^n + 1)\n    // another possible impl: b(x) = 2 * atan(x) / pi\n\n    let b = 1 / (Math.sqrt(r) + 1);\n\n    return inv ? 1 - b : b;\n}\n\nfunction mod(x: number, y: number) {\n    return ((x % y) + y) % y;\n}","import { Complex } from \"complex.js\";\nexport { Complex };\n\n/**\n * Canvas dimension data (width and height), as well as the current zoom level\n */\nexport interface CanvasData {\n    width: number,\n    height: number,\n\n    center: [number, number],\n    scale: number,\n}\n\n/**\n * Chunk data designating the size of the chunk and its offset from (0, 0) in canvas\n */\nexport interface ChunkData {\n    width: number,\n    height: number,\n    offx: number,\n    offy: number\n}\n\n/**\n * A partially evaluated function string.\n * The string here is already simplified, and the reciprocal optimization has already been applied,\n * but the is not fully computed to allow it to be passed as a Worker message.\n */\nexport interface PartialEvaluator {\n    fstr: string,\n    inverse: boolean\n}\n\ntype Numeric = Complex | number;\n\ninterface FunctionEvaluator { \n    type: \"function\",\n    f: ComplexFunction\n}\ninterface ConstantEvaluator { \n    type: \"constant\",\n    f: Numeric\n}\n\n/**\n * A fully evaluated function.\n * This has the sufficient knowledge to compute an output color from an input complex number.\n */\nexport interface Evaluator {\n    evaluator: FunctionEvaluator | ConstantEvaluator,\n\n    /**\n     * Signifies whether to use the reciprocal optimization: bfunc(1 / fz) = 1 - bfunc(fz)\n     */\n    inverse: boolean\n}\n\n/**\n * A function that takes a complex number to another complex number\n */\nexport type ComplexFunction = (z: Complex) => Numeric;\n\nnamespace Messages {\n    /**\n     * A request to compute the function across an entire canvas\n     */\n    export interface MainRequest {\n        action: \"mainRequest\",\n        pev: PartialEvaluator,\n        cd: CanvasData,\n        graphID: number\n    };\n    \n    /**\n     * Designation that the canvas is fully computed\n     */\n    export interface GraphDone {\n        action: \"done\",\n        time: number,\n        graphID: number\n    };\n\n    /**\n     * A request to compute the function across a chunk\n     */\n    export interface ChunkRequest {\n        action: \"chunkRequest\",\n        pev: PartialEvaluator,\n        cd: CanvasData,\n        chunk: ChunkData,\n        graphID: number\n    };\n\n    /**\n     * Designation that the chunk is fully computed (with the computed data from the chunk)\n     */\n    export interface ChunkDone {\n        action: \"chunkDone\",\n        chunk: ChunkData,\n        buf: ArrayBuffer,\n        graphID: number\n    };\n\n    /**\n     * Call to initialize\n     */\n    export interface Init {\n        action: \"init\"\n    };\n\n    /**\n     * Return call to designate initialization completed\n     */\n    export interface Ready {\n        action: \"ready\"\n    }\n\n}\nexport type InitIn = Messages.Init;\nexport type InitOut = Messages.Ready;\n\nexport type MainIn = Messages.MainRequest;\nexport type MainOut = Messages.ChunkDone | Messages.GraphDone;\n\nexport type LoaderIn = Messages.ChunkRequest;\nexport type LoaderOut = Messages.ChunkDone;","import arrayWithHoles from './_array_with_holes.mjs';\nimport iterableToArray from './_iterable_to_array.mjs';\nimport nonIterableRest from './_non_iterable_rest.mjs';\nimport unsupportedIterableToArray from './_unsupported_iterable_to_array.mjs';\n\nexport default function _toArray(arr) {\n  return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n","import { all, create } from \"mathjs\";\nimport { Complex, ComplexFunction, Evaluator } from \"./types\";\nconst math = create(all);\n\nconst constants = {\n    \"pi\": Complex.PI,\n    \"e\": Complex.E,\n    \"i\": Complex.I,\n    \"inf\": Complex.INFINITY,\n    \"infinity\": Complex.INFINITY,\n    \"epsilon\": Complex.EPSILON,\n    \"nan\": Complex.NAN\n} as const;\n\nnamespace Results {\n    export interface Z {\n        type: \"z\"\n    }\n\n    export interface Constant {\n        type: \"constant\",\n        value: Complex | number\n    }\n\n    export interface ComplexMethod {\n        type: \"method\",\n        name: keyof Complex\n    }\n    \n    export interface Function {\n        type: \"function\",\n        f: ComplexFunction\n    }\n}\n\ntype LookupResult = Results.Z | Results.ComplexMethod | Results.Constant;\ntype FoldResult   = Results.Z | Results.Function | Results.Constant;\n\nfunction isComplexMethod(n: string): n is keyof Complex {\n    return n in Complex.I;\n}\nfunction getFrom<O>(o: O, k: string): O[keyof O] | void {\n    if (k in o) return (o as any)[k];\n}\n\nfunction lookup(n: math.SymbolNode): LookupResult {\n    let { name } = n;\n\n    name = name.toLowerCase();\n    if (name === \"z\") return { type: \"z\" };\n    if (isComplexMethod(name)) return { type: \"method\", name }\n    if (name in constants) return {\n        type: \"constant\", \n        value: constants[name as keyof typeof constants]\n    };\n    // if (name in functions) return {\n    //     type: \"function\",\n    //     f: functions[name]\n    // }\n\n    throw new Error(`Unrecognized symbol [${name}]`)\n}\n\nconst operatorMapping: {[s: string]: (a: Complex) => AcceptableReturn} = {\n    \"add\": (a: Complex) => a.add.bind(a),\n    \"unaryPlus\": (a: Complex) => () => a,\n    \"subtract\": (a: Complex) => a.sub.bind(a),\n    \"unaryMinus\": (a: Complex) => a.neg.bind(a),\n    \"multiply\": (a: Complex) => a.mul.bind(a),\n    \"divide\": (a: Complex) => a.div.bind(a),\n    \"pow\": (a: Complex) => a.pow.bind(a),\n    \"factorial\": (a: Complex) => () => math.gamma(a.add(1) as any),\n} as const;\n\nfunction unwrap(val: FoldResult, z: Complex): Complex | number {\n    if (val.type === \"constant\") return val.value;\n    if (val.type === \"function\") return val.f(z);\n    if (val.type === \"z\") return z;\n\n    let _: never = val;\n    throw new Error(`Unrecognized fold result ${(val as any).type}`);\n}\n\ntype AcceptableReturn =\n    | number\n    | ((this: Complex, ...args: any[]) => any)\nfunction makeFunction(\n    f: (a: Complex) => AcceptableReturn, \n    args: math.MathNode[], \n    allowFunctions: boolean\n): FoldResult | undefined {\n    // can only accept z OR number | Complex\n    // functions should not be allowed.\n    let fargs = args.map(node => fold(node));\n\n    // if all constants, this can be computed as a constant\n    if (fargs.every((a): a is Results.Constant => a.type === \"constant\")) {\n        const [self, ...rest] = fargs.map(c => c.value);\n\n        const cself = Complex(self);\n        const met = f(cself);\n\n        if (typeof met === \"number\") return { type: \"constant\", value: met };\n        return { type: \"constant\", value: met.bind(cself)(...rest) };\n    }\n\n    const [self, ...rest] = fargs;\n    if (allowFunctions) return {\n        type: \"function\",\n        f: z => {\n            let a = Complex(unwrap(self, z));\n            let b = rest.map(arg => unwrap(arg, z));\n\n            const met = f(a);\n\n            if (typeof met === \"number\" /* re, im */) return met;\n            return met.bind(a)(...b);\n        }\n    };\n}\n\nfunction fold(n: math.MathNode, allowFunctions: false): Results.Z | Results.Constant;\nfunction fold(n: math.MathNode, allowFunctions: true): FoldResult;\nfunction fold(n: math.MathNode): FoldResult;\nfunction fold(n: math.MathNode, allowFunctions: boolean = true): FoldResult {\n    switch (n.type) {\n        case \"ConstantNode\":\n            return { type: \"constant\", value: n.value };\n        case \"FunctionNode\": {\n            const lk = lookup(n.fn);\n\n            if (lk.type === \"method\") {\n                const f = makeFunction(a => a[lk.name], n.args, allowFunctions);\n                if (typeof f === \"undefined\") throw new Error(`Unexpected function [${lk.name}]`);\n                return f;\n            } else if (lk.type === \"constant\") {\n                throw new Error(`Expected function, got constant [${n.fn.name} = ${lk.value}]`);\n            } else if (lk.type === \"z\") {\n                throw new Error(`Expected function, got [z]`);\n            }\n\n            let _: never = lk;\n            throw new Error(`Expected function, got [${(lk as any).type}]`);\n        }\n        case \"OperatorNode\": {\n            const op = getFrom(operatorMapping, n.fn);\n            const f = op ? makeFunction(op, n.args, allowFunctions) : undefined;\n\n            if (typeof f === \"undefined\") throw new Error(`Unexpected operator [${n.op}]`);\n            return f;\n        }\n        case \"ParenthesisNode\":\n            return fold(n.content);\n        case \"SymbolNode\": {\n            const lk = lookup(n);\n            if (lk.type === \"method\") {\n                throw new Error(`Unexpected function [${n.name}]`);\n            }\n\n            return lk;\n        }\n        default:\n            throw new Error(`Cannot parse [${n.type}] into complex function`);\n    }\n}\n\nexport function compile(fstr: string): Evaluator[\"evaluator\"] {\n    const fr = fold(math.parse(fstr));\n\n    switch (fr.type) {\n        case \"constant\":\n            return {\n                type: \"constant\",\n                f: fr.value,\n            }\n        case \"function\":\n            return fr\n        case \"z\":\n            return {\n                type: \"function\",\n                f: z => z\n            }\n        default:\n            let _: never = fr;\n            throw new Error(`Invalid fold result type ${(fr as any).type}`);\n    }\n}"],"names":["$2DZam","parcelRequire","$209r1","$51JoR","$12abef39f15d4dbb$export$2e2bcd8739ae039","arr","default","$RN0x4","$doFec","i","$ingza","$046ab4fc59af858e$var$math","$5Ndaw","create","all","$046ab4fc59af858e$var$constants","pi","Complex","PI","e","E","I","inf","INFINITY","infinity","epsilon","EPSILON","nan","NAN","$046ab4fc59af858e$var$getFrom","o","k","$046ab4fc59af858e$var$lookup","n","name","toLowerCase","type","$046ab4fc59af858e$var$isComplexMethod","value","Error","concat","$046ab4fc59af858e$var$operatorMapping","add","a","bind","unaryPlus","subtract","sub","unaryMinus","neg","multiply","mul","divide","div","pow","factorial","gamma","$046ab4fc59af858e$var$unwrap","val","z","f","$046ab4fc59af858e$var$makeFunction","args","allowFunctions","fargs","map","node","$046ab4fc59af858e$var$fold","every","ref","c","self","rest","slice","cself","met","apply","this","$Tzw6x","_fargs","self1","rest1","b","arg","_this","arguments","length","lk","fn","op","f1","undefined","content","lk1","$046ab4fc59af858e$export$ef7acd7185315e22","fstr","fr","parse","$d0e4415cf369ec6a$var$computeBuffer","ev","cd","chunk","evaluator1","evaluator","inverse","width","height","buf","ArrayBuffer","arr32","Uint32Array","fz","fill","$d0e4415cf369ec6a$var$polarToColor","abs","row","from","_","x","y","scale","_center","center","cx","cy","offx","offy","scaleX","scaleY","rx","ry","ref1","nx","ny","$d0e4415cf369ec6a$var$convPlanes","Math","floor","j","offset","set","j1","_loop","rad","theta","r","inv","hue","$d0e4415cf369ec6a$var$mod","h","s","l","m","g","ref2","ref3","ref4","ref5","ref6","ref7","$d0e4415cf369ec6a$var$hsl2rgb","sqrt","onmessage","data","action","pev","graphID","$d0e4415cf369ec6a$var$buildEvaluator","postMessage","start","performance","now","chunk1","buf1","msg1","console","log","msg2","time","trunc"],"version":3,"file":"chunkloader.bc8a9feb.js.map"}