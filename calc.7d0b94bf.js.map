{"mappings":"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","sources":["src/taylor2/calc.ts"],"sourcesContent":["import { create, all } from \"mathjs\";\n\nconst math = create(all);\n\nconst VARS = [\"x\", \"y\"] as const;\nconst [X, Y] = VARS.map(s => new math.SymbolNode(s));\n\nexport namespace Verify {\n    const VALID_FUNCTIONS = new Set([\n        \"cbrt\", \"sqrt\", \"nthRoot\", \"log10\", \"log\", \"pow\", \"exp\", \"abs\",\n        \"sin\",   \"cos\",   \"tan\",   \"sec\",   \"csc\",   \"cot\", \n        \"asin\",  \"acos\",  \"atan\",  \"asec\",  \"acsc\",  \"acot\", \n        \"sinh\",  \"cosh\",  \"tanh\",  \"sech\",  \"csch\",  \"coth\", \n        \"asinh\", \"acosh\", \"atanh\", \"asech\", \"acsch\", \"acoth\", \n    ]);\n\n    export function isConstant(n: math.SymbolNode) {\n        const { name } = n;\n        return VARS.includes(name as any)\n            || (name in math && !((math as any)[name] instanceof Function));\n    };\n\n    export function isFunction(n: math.SymbolNode) {\n        return VALID_FUNCTIONS.has(n.name);\n    };\n\n    export function validateTreeSymbols(n: math.MathNode) {\n        return n.forEach((node, _, parent) => {\n            if (node.type === \"SymbolNode\") {\n                if (parent.type === \"FunctionNode\" && parent.fn === node) {\n                    if (!Verify.isFunction(node)) throw new Error(`Undefined function ${node.name}`);\n                } else {\n                    if (!Verify.isConstant(node)) throw new Error(`Undefined symbol ${node.name}`);\n                }\n            }\n        });\n    }\n}\n\n/**\n * Input into this worker.\n * @param expr The expression\n * @param n Degree of approximation\n * @param a center x\n * @param b center y\n */\ntype TaylorMessage = [expr: string, n: number, a: number, b: number];\n\n/**\n * A term of the Taylor polynomial.\n * @param sign The sign of the term (true if (+) or 0, false if (-))\n * @param coeff The absolute value of the coefficient\n * @param xe The exponent on the x-term\n * @param ye The exponent on the y-term\n */\ntype TaylorTerm = [sign: boolean, coeff: math.MathNode, xe: number, ye: number];\n\nonmessage = function(e: MessageEvent<TaylorMessage>) {\n    postMessage(taylor(...e.data));\n}\n\n/**\n * Create a string representing the taylor polynomial expansion\n * @param expr The expression\n * @param n Degree of approximation\n * @param a center x\n * @param b center y\n * @returns the string\n */\nfunction taylor(expr: string, n = 2, a = 0, b = 0): string {\n    return displayTaylor(a, b, taylorTerms(expr, n, a, b)).toTex();\n}\n\n/**\n * Calculate the coefficients of (x + y)^n\n * @param n \n * @returns the coefficients\n */\nfunction pascalRow(n: number) {\n    return Array.from({length: n + 1}, (_, i) => math.combinations(n, i))\n}\n\n/**\n * Calculate a list of each term of the taylor polynomial\n * Each term consists of (pascal) * (coeff) * x^n * y^n / (factorial)\n * @param expr The expression\n * @param n Degree of approximation\n * @param a center x\n * @param b center y\n * @returns a list of terms\n */\nfunction taylorTerms(expr: string, n = 2, a = 0, b = 0): TaylorTerm[] {\n    // compute taylor\n    let exprNode: math.MathNode = math.simplify(expr);\n    Verify.validateTreeSymbols(exprNode);\n\n    let approxComponents: TaylorTerm[] = []\n    let order: math.MathNode[] = [] // partials. for n = 3: fxxx, fxxy, fxyy, fyyy\n\n    for (let i = 0; i <= n; i++) {\n        if (order.length == 0) {\n            order = [exprNode];\n        } else {\n            if (order.every(n => n.type === \"ConstantNode\")) break;\n            order = [\n                math.derivative(order[0], X),\n                ...order.map(e => math.derivative(e, Y))\n            ];\n        }\n\n        let pascal = pascalRow(i);\n        for (var j = 0; j <= i; j++) {\n            let p = pascal[j];\n            let e = math.simplify(order[j], \n                [...math.simplify.rules,\n                    \"sin(pi / 2) -> 1\",\n                    \"sin(pi) -> 0\",\n                    \"sin(3 * pi / 2) -> -1\",\n                    \"sin(2 * pi) -> 0\",\n\n                    \"cos(pi / 2) -> 0\",\n                    \"cos(pi) -> -1\",\n                    \"cos(3 * pi / 2) -> 0\",\n                    \"cos(2 * pi) -> 1\",\n                    n => n.transform(node => {\n                        if (node.type == \"OperatorNode\" && node.op == \"*\" && !node.implicit) node.implicit = true;\n                        return node;\n                    })\n                ],\n                {x: a, y: b}\n            );\n            let f = math.factorial(i);\n\n            approxComponents.push([...coeff(p, e, f), i - j, j]);\n        }\n    }\n\n    return approxComponents;\n}\n\nconst op = {\n    div(args: math.MathNode[])  { return new math.OperatorNode(\"/\", \"divide\", args)          },\n    imul(args: math.MathNode[]) { return new math.OperatorNode(\"*\", \"multiply\", args, true)  },\n    emul(args: math.MathNode[]) { return new math.OperatorNode(\"*\", \"multiply\", args, false) },\n    neg(arg: math.MathNode)     { return new math.OperatorNode(\"-\", \"unaryMinus\", [arg])     },\n    add(args: math.MathNode[])  { return new math.OperatorNode(\"+\", \"add\", args)             },\n    sub(args: math.MathNode[])  { return new math.OperatorNode(\"-\", \"subtract\", args)        },\n    pow(args: math.MathNode[])  { return new math.OperatorNode(\"^\", \"pow\", args)             },\n}\n\n/**\n * Utility function to create a node representing the coefficient.\n * @param pascal Pascal component\n * @param deriv The derivative\n * @param fact The factorial component\n * @returns the sign and node of the coefficient\n */\nfunction coeff(pascal: number, deriv: math.MathNode, fact: number): [sign: boolean, coeff: math.MathNode] {\n    // coeff = (pascal) * (derivative) / factorial\n    \n    let sign = Math.sign(pascal) * Math.sign(fact) >= 0;\n    pascal   = Math.abs(pascal);\n    fact     = Math.abs(fact);\n\n    let pf = op.div([new math.ConstantNode(pascal), new math.ConstantNode(fact)]);\n\n    let prod = math.simplify(op.imul([pf, deriv]), [\n        ...math.simplify.rules, \n        n => n.transform(node => node.type == \"FunctionNode\" ? new math.ConstantNode(node.evaluate()) : node)\n    ]);\n    prod = prod.transform(n => {\n        if (n.type == \"OperatorNode\" && n.fn == \"unaryMinus\") {\n            sign = !sign;\n            return n.args[0];\n        }\n        return n;\n    });\n\n    return [sign, math.simplify(prod)];\n}\n\n/**\n * Take the sign boolean and a node and combine it into a new node.\n * @param s sign boolean\n * @param n node\n * @returns the new node\n */\nfunction signed(s: boolean, n: math.MathNode) {\n    return s ? n : op.neg(n)\n}\n\n/**\n * (x - a)^b\n * @param varNode x\n * @param exp b\n * @param shift a\n * @returns the node\n */\nfunction variableExpNode(varNode: math.SymbolNode, exp: number, shift: number) {\n    let node: math.MathNode = varNode;\n    \n    const shiftNode = new math.ConstantNode(Math.abs(shift));\n    if (shift < 0) node = new math.ParenthesisNode(op.add([node, shiftNode]));\n    else if (shift > 0) node = new math.ParenthesisNode(op.sub([node, shiftNode]));\n\n    if (exp !== 1) node = op.pow([node, new math.ConstantNode(exp)]);\n\n    return node;\n}\n\n/**\n * Convert a list of taylor terms & the center position into a node representing the entire Taylor polynomial\n * @param a center x\n * @param b center y\n * @param tc the taylor terms\n * @returns the tree representing the entire Taylor polynomial\n */\nfunction displayTaylor(a: number, b: number, tc: TaylorTerm[]): math.MathNode {\n    let taylorTermNodes = tc.map(([sign, coeff, xe, ye]) => {\n        coeff = math.simplify(coeff);\n        if (coeff.type == \"ConstantNode\" && coeff.value == 0) return;\n        \n        let args = [];\n\n        if (xe != 0) args.push(variableExpNode(X, xe, a));\n        if (ye != 0) args.push(variableExpNode(Y, ye, b));\n\n        let expr: math.MathNode;\n        if (args.length == 0) {\n            return [sign, coeff] as const;\n        } else if (args.length == 1) {\n            [expr] = args;\n        } else {\n            expr = op.imul(args);\n        }\n        \n        if (coeff.type !== \"ConstantNode\" || coeff.value !== 1) {\n            expr = op.imul([coeff, expr]);\n        }\n\n        return [sign, expr] as const;\n    }).filter(<T>(x?: T): x is T => typeof x !== \"undefined\");\n\n    if (taylorTermNodes.length == 0) return new math.ConstantNode(0);\n\n    let [first, ...rest] = taylorTermNodes;\n    return rest.reduce((acc, [s, n]) => s ? op.add([acc, n]) : op.sub([acc, n]), signed(...first))\n}\n\nexport default taylor;\nexport {TaylorMessage};"],"names":["$c185697d0408343e$export$91a8e56769aeb334","VALID_FUNCTIONS","$2DZam","parcelRequire","$c185697d0408343e$var$math","$5Ndaw","create","all","$c185697d0408343e$var$VARS","$c185697d0408343e$var$ref","default","map","s","SymbolNode","$c185697d0408343e$var$X","$c185697d0408343e$var$Y","$c185697d0408343e$var$taylor","expr","n","arguments","length","a","b","$c185697d0408343e$var$displayTaylor","$c185697d0408343e$var$taylorTerms","toTex","$c185697d0408343e$var$pascalRow","Array","from","_","i","combinations","order","exprNode","every","type","derivative","concat","$Tzw6x","e","pascal","j","p","e1","simplify","rules","transform","node","op","implicit","x","y","f","factorial","approxComponents","push","$c185697d0408343e$var$coeff","n1","validateTreeSymbols","i1","Set","isConstant","name","includes","Function","isFunction","has","forEach","parent","fn","Error","onmessage","postMessage","apply","data","$c185697d0408343e$var$op","args","OperatorNode","arg","deriv","fact","sign","Math","abs","pf","ConstantNode","prod","evaluate","$c185697d0408343e$var$signed","$c185697d0408343e$var$variableExpNode","varNode","exp","shift","shiftNode","ParenthesisNode","tc","taylorTermNodes","param","_param","coeff1","xe","ye","value","filter","_taylorTermNodes","$1nPzy","first","slice","reduce","acc","$c185697d0408343e$export$2e2bcd8739ae039"],"version":3,"file":"calc.7d0b94bf.js.map"}