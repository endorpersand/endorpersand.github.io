{"mappings":"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","sources":["src/mvc/taylor2.ts","src/taylor2/display.ts"],"sourcesContent":["import { create, all } from \"mathjs\";\n\nconst math = create(all);\n\nlet x = math.parse(\"x\") as math.SymbolNode;\nlet y = math.parse(\"y\") as math.SymbolNode;\n\ntype TaylorComponents = [number | math.Fraction, number, number][];\ntype TaylorInformation = [number, number, TaylorComponents];\n\nfunction coeffs(n: number) {\n    // calculate the coefficients of (x + y)^n\n    return Array.from({length: n + 1}, (_, i) => math.combinations(n, i))\n}\n\n// def taylor(expr, a = 0, b = 0, h = x, k = y, n = 2):\n//     assert n >= 0\n\n//     approx = 0\n//     order = []\n\n//     for i in range(n + 1):\n//         if len(order) == 0:\n//             order = [expr]\n//         else:\n//             first_order = order[0]\n//             new_order = [diff(first_order, x)]\n//             new_order.extend(diff(e, y) for e in order)\n//             order = new_order\n        \n//         for j, [c, e] in enumerate(zip(all_coeffs(i), order)):\n//             h_term = h ** j if j != 0 else 1\n//             k_term = k ** (i - j) if (i - j) != 0 else 1\n\n//             approx += c * h_term * k_term * e.subs(x, a).subs(y, b) / math.factorial(i)\n        \n//     return approx\n\nfunction taylorComponents(expr: string, n = 2, a = 0, b = 0): TaylorInformation {\n\n    // compute taylor\n    let exprNode: math.MathNode = math.parse(expr);\n    let approxComponents: TaylorComponents = [] // coeff, x exp, y exp\n    let order: math.MathNode[] = []\n\n    for (let i = 0; i <= n; i++) {\n        if (order.length == 0) {\n            order.push(exprNode);\n        } else {\n            let first_order = order[0]\n            let new_order = [math.derivative(first_order, x)];\n            \n            for (let e of order) {\n                new_order.push(math.derivative(e, y));\n            }\n\n            order = new_order;\n        }\n\n        let cs = coeffs(i);\n        for (var j = 0; j <= i; j++) {\n            let c = cs[j];\n            let e = order[j].evaluate({x: a, y: b});\n            let f = math.factorial(i);\n\n            let fullCoeff: number | math.Fraction = math.fraction(math.multiply(c, e), f) as math.Fraction;\n            approxComponents.push([fullCoeff, i - j, j]);\n        }\n    }\n\n    return [a, b, approxComponents];\n}\n\nfunction buildTerm(variable: string, shift: number, exp: number) {\n    if (exp != 0) {\n        let p = math.simplify(`${variable} - ${shift}`).toString();\n        if (p.length != variable.length) p = `(${p})`;\n\n        return math.simplify(`a ^ ${exp}`).toString().replace(\"a\", p);\n    }\n}\n\nfunction stringify(v: number | math.Fraction) {\n    if (math.isInteger(v)) {\n        v = math.round(v);\n    }\n    return math.format(v);\n}\n\nfunction displayTaylor(ti: TaylorInformation): string {\n    let [a, b, tc] = ti;\n    let taylorStringComponents = tc.map(([c, xe, ye]) => {\n        let segs: string[] = [];\n        if (c == 0) return;\n        \n        let unitCoeff = c == 1 || c == -1;\n        if (!unitCoeff) {\n            segs.push(stringify(c));\n        }\n        let xt = buildTerm(\"x\", a, xe);\n        let yt = buildTerm(\"y\", b, ye);\n        if (typeof xt === \"string\") {\n            segs.push(xt);\n        }\n        if (typeof yt === \"string\") {\n            if (xt?.length == 1) segs.push(\"*\");\n            segs.push(yt);\n        }\n    \n        if (unitCoeff) {\n            // if coeff is 1 or -1, then the sign should be displayed in the first term\n            // if this term is actually a x^0y^0 term, display -1 or 1\n    \n            let first;\n            if (segs.length == 0) {\n                first = \"1\";\n            } else {\n                first = segs[0];\n            }\n    \n            if (c == -1) first = \"-\" + first;\n    \n            segs[0] = first;\n        }\n        return segs.join(\"\");\n    }).filter(x => typeof x != \"undefined\") as string[];\n\n    if (taylorStringComponents.length == 0) return \"0\";\n\n    return taylorStringComponents.reduce((acc, cv) => {\n        let nextTermNeg = cv.startsWith(\"-\");\n\n        if (nextTermNeg) {\n            return `${acc} - ${cv.slice(1)}`;\n        } else {\n            return `${acc} + ${cv}`;\n        }\n    });\n}\n\nfunction taylor(expr: string, n = 2, a = 0, b = 0): string {\n    return displayTaylor(taylorComponents(expr, n, a, b));\n}\n\nexport default taylor;","import { create, all } from \"mathjs\";\nimport taylor from '../mvc/taylor2';\n\ndeclare var MathJax: any;\nconst math = create(all);\ntype MaybeTex = {\n    valid: false,\n    expr: string,\n} | {\n    valid: true,\n    expr: string,\n    tex: string\n};\n\nlet centerDiv = document.querySelector(\"#centerDiv\")!      as HTMLDivElement,\n    [centerX, centerY] = centerDiv.querySelectorAll(\"input\"),\n    funcInput = document.querySelector(\"#func input\")!     as HTMLInputElement,\n    funcTex = document.querySelector(\"#funcTex\")!          as HTMLDivElement,\n    resultTex = document.querySelector(\"#resultTex\")!      as HTMLDivElement,\n    approxNRadio = document.querySelector(\"#appn\")!        as HTMLInputElement,\n    approxNInput = document.querySelector(\"#appninput\")!   as HTMLInputElement,\n    computeButton = document.querySelector(\"#compute\")!    as HTMLButtonElement;\n\nlet tex: MaybeTex = {valid: false, expr: \"\"};\n\nupdateFuncTex();\nupdateResultTex();\nfuncInput.addEventListener(\"input\", updateFuncTex);\ndocument.querySelectorAll(\"input[name=approx]\").forEach(i => i.addEventListener(\"change\", radioUpdate));\ncomputeButton.addEventListener(\"click\", updateResultTex);\n\nfunction verifyExpression(expr: string, replEq = \"=\"): MaybeTex {\n    let fexpr = \"f(x, y) = \" + expr;\n    let tex;\n    try {\n        tex = math.parse(fexpr).toTex().replace(\":=\", replEq);\n    } catch {\n        return {valid: false, expr}\n    }\n\n    return {valid: true, expr, tex};\n}\n\nfunction findN() {\n    let rads = [...document.querySelectorAll(\"input[name=approx]\")];\n    let v = (rads as HTMLInputElement[])\n        .filter(e => e.checked)\n        .map(e => e.value)[0];\n    \n    if (v != \"\") return +v;\n    return +approxNInput.value;\n}\n\nfunction updateTex() {\n    MathJax.typeset();\n}\n\nfunction updateFuncTex() {\n    tex = verifyExpression(funcInput.value);\n    resultTex.classList.add(\"notCurrentFunc\");\n\n    if (tex.valid) {\n        funcTex.innerHTML = `$$${tex.tex}$$`;\n    } else {\n        funcTex.innerHTML = `$$\\\\color{red}{?}$$`\n    }\n    updateTex();\n}\n\nfunction updateResultTex() {\n    let succ = false;\n    if (tex.valid) {\n        let taytay: string = \"\";\n        resultTex.classList.remove(\"err\");\n        resultTex.classList.remove(\"notCurrentFunc\");\n        try {\n            taytay = taylor(tex.expr, findN(), +centerX.value, +centerY.value);\n        } catch (e) {\n            console.log(e);\n            if (e instanceof Error && e.message.startsWith(\"Undefined symbol\")) {\n                let msg = e.message;\n                let sym = msg.slice(\"Undefined symbol \".length);\n                if (sym.includes(\"x\") || sym.includes(\"y\")) {\n                    msg += \" (try adding * here?)\"\n                }\n                resultTex.innerHTML = msg;\n                resultTex.classList.add(\"err\");\n                return;\n            }\n        }\n        let rTex = verifyExpression(taytay, \"\\\\approx\");\n        if (rTex.valid) {\n            resultTex.innerHTML = `$$${rTex.tex}$$`;\n            succ = true;\n        }\n    }\n    if (!succ) {\n        resultTex.innerHTML = `$$\\\\color{red}{?}$$`\n    }\n    updateTex();\n}\n\nfunction radioUpdate() {\n    if (approxNRadio.checked) {\n        approxNInput.disabled = false;\n    } else {\n        approxNInput.disabled = true;\n    }\n}"],"names":["$1800b820808e1fb4$var$math","create","$ghe96","all","$1800b820808e1fb4$var$x","parse","$1800b820808e1fb4$var$y","$1800b820808e1fb4$var$coeffs","n","Array","from","length","_","i","combinations","$1800b820808e1fb4$var$buildTerm","variable","shift","exp","p","simplify","toString","replace","$1800b820808e1fb4$var$displayTaylor","ti","a","b","tc","taylorStringComponents","map","c","xe","ye","segs","unitCoeff","v","push","isInteger","round","format","xt","yt","first","join","filter","x","reduce","acc","cv","startsWith","slice","$1800b820808e1fb4$export$2e2bcd8739ae039","expr","exprNode","approxComponents","order","first_order","new_order","derivative","e","cs","j","evaluate","y","f","factorial","fullCoeff","fraction","multiply","$1800b820808e1fb4$var$taylorComponents","$7eb4b9aeefed061a$var$math","$7eb4b9aeefed061a$var$centerDiv","document","querySelector","$7eb4b9aeefed061a$var$centerX","$7eb4b9aeefed061a$var$centerY","querySelectorAll","$7eb4b9aeefed061a$var$funcInput","$7eb4b9aeefed061a$var$funcTex","$7eb4b9aeefed061a$var$resultTex","$7eb4b9aeefed061a$var$approxNRadio","$7eb4b9aeefed061a$var$approxNInput","$7eb4b9aeefed061a$var$computeButton","$7eb4b9aeefed061a$var$tex","valid","$7eb4b9aeefed061a$var$verifyExpression","replEq","tex","fexpr","toTex","$7eb4b9aeefed061a$var$updateTex","MathJax","typeset","$7eb4b9aeefed061a$var$updateFuncTex","value","classList","add","innerHTML","$7eb4b9aeefed061a$var$updateResultTex","succ","taytay","remove","checked","$7eb4b9aeefed061a$var$findN","console","log","Error","message","msg","sym","includes","rTex","$7eb4b9aeefed061a$var$radioUpdate","disabled","addEventListener","forEach"],"version":3,"file":"taylor2.9043dfd9.js.map"}