{"mappings":"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","sources":["src/complexgrapher/worker/chunkloader.ts"],"sourcesContent":["import { create, all } from \"mathjs\";\nimport { Complex, CanvasData, ChunkData, PartialEvaluator, Evaluator, LoaderIn, LoaderOut, MainIn, InitIn } from \"../types\";\nconst math = create(all);\n\nonmessage = function (e: MessageEvent<InitIn | MainIn | LoaderIn>) {\n    let data = e.data;\n\n    if (data.action === \"init\") {\n        self.postMessage({action: \"ready\"});\n        return;\n    }\n\n    let {pev, cd} = data;\n    let chunk;\n\n    if (data.action === \"chunkRequest\") {\n        chunk = data.chunk;\n    } else if (data.action === \"mainRequest\") {\n        chunk = {\n            width: cd.width, \n            height: cd.height, \n            offx: 0, \n            offy: 0\n        };\n    } else {\n        let _: never = data;\n        throw new Error(\"Unrecognized request into chunkLoader\");\n    }\n\n    let ev = buildEvaluator(pev);\n    let buf = computeBuffer(ev, cd, chunk);\n\n    let msg: LoaderOut = {action: \"chunkDone\", buf, chunk};\n    postMessage(msg, [buf] as any);\n}\n\n/**\n * Take a partially computed evaluator and fully evaluate it.\n * @param pev partially computed evaluator\n * @returns the full evaluator\n */\nfunction buildEvaluator(pev: PartialEvaluator): Evaluator {\n    let {fstr, inverse} = pev;\n    return {f: math.evaluate(fstr), inverse}\n}\n\n/**\n * Compute the ArrayBuffer for the chunk\n * @param ev The function evaluator\n * @param cd Canvas dimension data\n * @param chunk Chunk position and size\n * @returns the computed chunk\n */\nfunction computeBuffer(ev: Evaluator, cd: CanvasData, chunk: ChunkData): ArrayBuffer {\n    let {f, inverse} = ev;\n    let {width, height} = chunk;\n\n    let buf = new ArrayBuffer(4 * width * height);\n    let arr32 = new Uint32Array(buf);\n    for (var i = 0; i < width; i++) {\n        for (var j = 0; j < height; j++) {\n            let k = width * j + i;\n            // compute value\n            let fz = forceComplex(f( convPlanes(i, j, cd, chunk) ));\n            // if (typeof fz !== 'number' && fz.type !== 'Complex') throw new TypeError('Input value is not a number');\n            \n            // get color\n            if (!Number.isFinite(fz.re) || !Number.isFinite(fz.im)) {\n                let infColor = +!inverse * 0xFFFFFF;\n                arr32[k] = (0xFF << 24) | infColor;\n                continue;\n            }\n\n            let { r, phi } = fz.toPolar();\n            arr32[k] = polarToColor(r, phi, inverse);\n        }\n    }\n    return buf;\n}\n\n/**\n  * Converts xy canvas pixels to values in the complex plane\n * @param x x coord\n * @param y y coord\n * @param cd canvas data\n * @param chunk chunk offset data\n * @returns the complex value associated\n */\nfunction convPlanes(x: number, y: number, cd: CanvasData, chunk: ChunkData) {\n    //converts xy pixel plane to complex plane\n\n    // let cmx =  (row - rx) / (rx / 2) / scale,\n    //     cmy = -(col - ry) / (ry / 2) / scale;\n\n    // row - rx: distance from center, in canvas pixels\n    // / (rx / 2): normalizes that so the edge is 2\n    // / scale: scale mult.\n\n    let {width, height, zoom} = cd;\n    let {offx, offy} = chunk;\n    let [rx, ry] = [(width - 1) / 2, (height - 1) / 2];\n    let cmx =  (x + offx - rx) / (rx / 2) / zoom,\n        cmy = -(y + offy - ry) / (ry / 2) / zoom;\n    return math.complex(cmx, cmy) as unknown as Complex;\n}\n\n/**\n * Force the input to be a complex value\n * @param z maybe complex value\n * @returns Complex value\n */\nfunction forceComplex(z: number | Complex) {\n    // z as any is ok here\n    return math.complex(z as any);\n}\n\n/**\n * Takes a polar coordinate and maps it to a color\n * @param rad Radius\n * @param theta Angle\n * @param inverse Whether to invert the brightness\n * @returns the associated color in RGB\n */\nfunction polarToColor(rad: number, theta: number, inverse: boolean) {\n    let hue, brightness, c, x, m, r, g, b;\n    hue = mod(theta * 3 / Math.PI, 6); // hue [0,6)\n    if (inverse) hue = 6 - hue;\n\n    brightness = bfunc(rad, inverse);\n    c = 1 - Math.abs(2 * brightness - 1);\n    x = c * (1 - Math.abs(mod(hue, 2) - 1));\n    m = brightness - c / 2;\n    if (0 <= hue && hue < 1) [r, g, b] = [c, x, 0];\n    else if (1 <= hue && hue < 2) [r, g, b] = [x, c, 0];\n    else if (2 <= hue && hue < 3) [r, g, b] = [0, c, x];\n    else if (3 <= hue && hue < 4) [r, g, b] = [0, x, c];\n    else if (4 <= hue && hue < 5) [r, g, b] = [x, 0, c];\n    else if (5 <= hue && hue < 6) [r, g, b] = [c, 0, x];\n    else [r, g, b] = [c, x, 0]; // should never happen?\n\n    return (    0xFF  << 24) | \n    (((b + m) * 0xFF) << 16) |\n    (((g + m) * 0xFF) <<  8) |\n     ((r + m) * 0xFF);\n}\n\n/**\n * Brightness computation\n * @param r Radius\n * @param inv Whether to invert the brightness\n * @returns the brightness as float\n */\nfunction bfunc(r: number, inv: boolean) {\n    // bfunc needs to match the identities:\n    // b(1/x) = 1 - b(x)\n    // b(0) = 0\n\n    // the current impl uses b(x) = 1 - 1/(x^n + 1)\n    // another possible impl: b(x) = 2 * atan(x) / pi\n\n    let b = 1 / (Math.sqrt(r) + 1);\n\n    return inv ? b : 1 - b;\n}\n\nfunction mod(x: number, y: number) {\n    return ((x % y) + y) % y;\n}"],"names":["$5Ndaw","parcelRequire","$d0e4415cf369ec6a$var$math","create","all","$d0e4415cf369ec6a$var$convPlanes","x","y","cd","chunk","width","height","zoom","offx","offy","ref","rx","ry","cmx","cmy","complex","$d0e4415cf369ec6a$var$forceComplex","z","$d0e4415cf369ec6a$var$polarToColor","rad","theta","inverse","hue","brightness","c","m","r","g","b","$d0e4415cf369ec6a$var$mod","Math","PI","inv","sqrt","$d0e4415cf369ec6a$var$bfunc","abs","ref1","ref2","ref3","ref4","ref5","ref6","onmessage","e","data","action","pev","Error","ev","fstr","f","evaluate","$d0e4415cf369ec6a$var$buildEvaluator","buf","ArrayBuffer","arr32","Uint32Array","i","j","k","fz","Number","isFinite","re","im","toPolar","phi","infColor","$d0e4415cf369ec6a$var$computeBuffer","postMessage","self"],"version":3,"file":"chunkloader.d3595d56.js.map"}